<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Soares-Furtado Team Observation Query</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Crimson+Pro:ital,wght@0,400;0,600;1,400&family=DM+Mono:wght@400;500&family=DM+Sans:wght@400;500;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="styles.css">
    
    <!-- Plotly for spectrum plotting -->
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
</head>
<body>
    <div class="container">
        <header>
            <div class="site-badge">
                <a href="https://www.salt.ac.za/" target="_blank">Southern African Large Telescope (SALT)</a>
            </div>
            <h1>Soares-Furtado Team Observation Query</h1>
            <p class="subtitle">Search for SALT observations from the Ursa Major Spectral Survey</p>
        </header>

        <section class="search-section">
            <label class="search-label" for="gaia-id">Gaia DR3 Source ID</label>
            <div class="search-wrapper">
                <div class="input-container">
                    <input type="text" id="gaia-id" class="search-input" placeholder="e.g., 4654969496256092032" autocomplete="off">
                    <div class="search-dropdown" id="search-dropdown"></div>
                </div>
                <button class="search-btn" onclick="searchTarget()">Search</button>
            </div>
            <div class="search-links">
                <a href="#" onclick="showAllTargets(); return false;">Browse all targets</a>
                <span class="simbad-link" id="simbad-link">
                    · <a href="#" id="simbad-url" target="_blank">SIMBAD ↗</a>
                </span>
                <span class="vizier-link" id="vizier-link">
                    · <a href="#" id="vizier-url" target="_blank">VizieR ↗</a>
                </span>
            </div>
        </section>
        
        <style>
            .search-section {
                max-width: 600px;
                margin: 0 auto;
            }
            .search-wrapper {
                display: flex;
                gap: 0;
                align-items: stretch;
            }
            .input-container {
                position: relative;
                flex: 1;
            }
            .search-input {
                width: 100%;
                box-sizing: border-box;
                border-radius: 8px 0 0 8px;
                border-right: none;
            }
            .search-btn {
                border-radius: 0 8px 8px 0;
                padding: 0 24px;
                white-space: nowrap;
            }
            .search-dropdown {
                display: none;
                position: absolute;
                top: 100%;
                left: 0;
                right: 0;
                background: #fff;
                border: 1px solid #ddd;
                border-top: none;
                border-radius: 0 0 6px 6px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.1);
                z-index: 100;
                max-height: 200px;
                overflow-y: auto;
            }
            .search-dropdown.visible {
                display: block;
            }
            .dropdown-label {
                padding: 8px 12px;
                font-size: 11px;
                color: #555;
                font-weight: 600;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #ddd;
                background: #f8f8f8;
            }
            .dropdown-item {
                padding: 10px 12px;
                cursor: pointer;
                font-family: 'DM Mono', monospace;
                font-size: 13px;
                color: #1a1a2e;
                transition: background 0.15s;
            }
            .dropdown-item:hover {
                background: #e8f0fe;
                color: #1a56db;
            }
            .dropdown-item:last-child {
                border-radius: 0 0 6px 6px;
            }
            .search-links {
                margin-top: 10px;
                text-align: center;
            }
            
            /* Team Rejected badge styling */
            .quality-badge.team-rejected {
                background: #fef2f2;
                color: #b91c1c;
                border: 1px solid #fecaca;
                font-weight: 500;
            }
            
            /* Load CMD button */
            .load-cmd-btn {
                display: inline-flex;
                align-items: center;
                gap: 0.5rem;
                background: #f8fafc;
                border: 1px solid #e2e8f0;
                color: #64748b;
                padding: 0.75rem 1.25rem;
                border-radius: 8px;
                font-family: 'DM Sans', sans-serif;
                font-size: 0.875rem;
                cursor: pointer;
                transition: all 0.15s;
                margin: 1rem 0;
            }
            .load-cmd-btn:hover {
                background: #f1f5f9;
                border-color: #cbd5e1;
                color: #475569;
            }
            .load-cmd-btn:disabled {
                cursor: not-allowed;
                opacity: 0.6;
            }
            .stellar-section-placeholder {
                text-align: center;
                padding: 1rem;
            }
            
            /* Collapse CMD button */
            .stellar-header {
                display: flex;
                justify-content: flex-end;
                margin-bottom: 0.5rem;
            }
            .collapse-cmd-btn {
                background: transparent;
                border: 1px solid #cbd5e1;
                color: #64748b;
                padding: 0.25rem 0.75rem;
                border-radius: 4px;
                font-family: 'DM Sans', sans-serif;
                font-size: 0.75rem;
                cursor: pointer;
                transition: all 0.15s;
            }
            .collapse-cmd-btn:hover {
                background: #f1f5f9;
                color: #475569;
            }
            
            /* ============================================
               Spectrum Viewer Styles
               ============================================ */
            
            .spectrum-viewer {
                background: #1e293b;
                border-radius: 12px;
                padding: 1.5rem;
                margin-top: 1.5rem;
                display: none;
            }
            
            .spectrum-viewer.visible {
                display: block;
            }
            
            .spectrum-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 1rem;
                flex-wrap: wrap;
                gap: 0.75rem;
            }
            
            .spectrum-title {
                color: #e2e8f0;
                font-family: 'DM Sans', sans-serif;
                font-size: 1rem;
                font-weight: 500;
            }
            
            .spectrum-close-btn {
                background: transparent;
                border: 1px solid #475569;
                color: #94a3b8;
                padding: 0.25rem 0.75rem;
                border-radius: 4px;
                font-family: 'DM Sans', sans-serif;
                font-size: 0.75rem;
                cursor: pointer;
                transition: all 0.15s;
            }
            
            .spectrum-close-btn:hover {
                background: #334155;
                color: #e2e8f0;
            }
            
            .spectrum-controls {
                display: flex;
                gap: 1rem;
                margin-bottom: 1rem;
                flex-wrap: wrap;
                align-items: center;
            }
            
            .control-group {
                display: flex;
                align-items: center;
                gap: 0.5rem;
            }
            
            .control-group label {
                color: #94a3b8;
                font-family: 'DM Sans', sans-serif;
                font-size: 0.8rem;
            }
            
            .control-group input {
                width: 80px;
                padding: 0.4rem 0.6rem;
                font-size: 0.8rem;
                border: 1px solid #475569;
                border-radius: 4px;
                background: #0f172a;
                color: #e2e8f0;
                font-family: 'DM Mono', monospace;
            }
            
            .control-group input:focus {
                outline: none;
                border-color: #3b82f6;
            }
            
            .spectrum-btn {
                background: #334155;
                border: 1px solid #475569;
                color: #e2e8f0;
                padding: 0.4rem 0.75rem;
                border-radius: 4px;
                font-family: 'DM Sans', sans-serif;
                font-size: 0.8rem;
                cursor: pointer;
                transition: all 0.15s;
            }
            
            .spectrum-btn:hover {
                background: #475569;
                border-color: #64748b;
            }
            
            .spectrum-btn.active {
                background: #3b82f6;
                border-color: #3b82f6;
            }
            
            .control-divider {
                width: 1px;
                height: 24px;
                background: #475569;
                margin: 0 0.5rem;
            }
            
            .line-btn {
                font-weight: 500;
            }
            
            #halpha-btn.active {
                background: #ec4899;
                border-color: #ec4899;
            }
            
            #lithium-btn.active {
                background: #f59e0b;
                border-color: #f59e0b;
            }
            
            #bary-btn.active {
                background: #10b981;
                border-color: #10b981;
            }
            
            .line-btn-group {
                display: inline-flex;
                gap: 0.5rem;
                flex-shrink: 0;
            }
            
            .rv-controls {
                margin-top: 0.75rem;
                padding-top: 0.75rem;
                border-top: 1px solid #334155;
            }
            
            .template-select {
                padding: 0.4rem 0.6rem;
                font-size: 0.8rem;
                border: 1px solid #475569;
                border-radius: 4px;
                background: #0f172a;
                color: #e2e8f0;
                font-family: 'DM Sans', sans-serif;
                cursor: pointer;
            }
            
            .template-select:focus {
                outline: none;
                border-color: #3b82f6;
            }
            
            .rv-btn {
                background: #7c3aed;
                border-color: #7c3aed;
            }
            
            .rv-btn:hover {
                background: #6d28d9;
                border-color: #6d28d9;
            }
            
            .rv-result {
                display: inline-flex;
                align-items: center;
                gap: 1rem;
                margin-left: 0.5rem;
                color: #e2e8f0;
                font-family: 'DM Mono', monospace;
                font-size: 0.85rem;
            }
            
            .rv-result .rv-value {
                color: #a78bfa;
                font-weight: 600;
            }
            
            .rv-result .rv-label {
                color: #64748b;
                font-size: 0.75rem;
            }
            
            .rv-result .computing {
                color: #94a3b8;
            }
            
            .rv-result .error {
                color: #f87171;
            }
            
            .show-ccf-btn {
                background: transparent;
                border: 1px solid #475569;
                color: #94a3b8;
                padding: 0.2rem 0.5rem;
                border-radius: 4px;
                font-size: 0.7rem;
                cursor: pointer;
                margin-left: 0.5rem;
            }
            
            .show-ccf-btn:hover {
                background: #334155;
                color: #e2e8f0;
            }
            
            /* Condensed file list styling */
            .obs-files {
                padding: 0.5rem 0.75rem;
            }
            
            .files-grid {
                display: flex;
                flex-wrap: wrap;
                gap: 0.25rem 0.5rem;
                font-size: 0.7rem;
            }
            
            .file-item {
                display: inline-flex;
                align-items: center;
                gap: 0.25rem;
                padding: 0.15rem 0.35rem;
                background: rgba(0,0,0,0.03);
                border: 1px solid rgba(0,0,0,0.06);
                border-radius: 3px;
                font-family: 'DM Mono', monospace;
                white-space: nowrap;
                color: #64748b;
            }
            
            .file-badge {
                font-size: 0.55rem;
                padding: 0.1rem 0.2rem;
                border-radius: 2px;
                background: rgba(0,0,0,0.05);
                color: #94a3b8;
                text-transform: uppercase;
                font-weight: 500;
            }
            
            .file-badge.main {
                background: #dbeafe;
                color: #3b82f6;
            }
            
            .file-actions {
                margin-top: 0.5rem;
                padding-top: 0.5rem;
            }
            
            #spectrum-plot {
                width: 100%;
                height: 400px;
                border-radius: 8px;
                overflow: hidden;
            }
            
            .spectrum-loading {
                display: flex;
                align-items: center;
                justify-content: center;
                height: 300px;
                color: #94a3b8;
                font-family: 'DM Sans', sans-serif;
            }
            
            .spectrum-loading::after {
                content: '';
                animation: dots 1.5s infinite;
            }
            
            @keyframes dots {
                0%, 20% { content: '.'; }
                40% { content: '..'; }
                60%, 100% { content: '...'; }
            }
            
            .spectrum-error {
                background: rgba(239, 68, 68, 0.1);
                border: 1px solid #ef4444;
                color: #fca5a5;
                padding: 1rem;
                border-radius: 8px;
                font-family: 'DM Sans', sans-serif;
                font-size: 0.875rem;
            }
            
            /* Plot button in observation items */
            .plot-spectrum-btn {
                display: inline-flex;
                align-items: center;
                gap: 0.35rem;
                background: #3b82f6;
                border: none;
                color: #fff;
                padding: 0.4rem 0.75rem;
                border-radius: 4px;
                font-family: 'DM Sans', sans-serif;
                font-size: 0.75rem;
                cursor: pointer;
                transition: all 0.15s;
                margin-right: 0.5rem;
            }
            
            .plot-spectrum-btn:hover {
                background: #2563eb;
            }
            
            .plot-spectrum-btn:disabled {
                background: #64748b;
                cursor: not-allowed;
            }
            
            .plot-both-btn {
                background: linear-gradient(90deg, #38bdf8 0%, #f87171 100%);
            }
            
            .plot-both-btn:hover {
                background: linear-gradient(90deg, #0ea5e9 0%, #ef4444 100%);
            }
            
            .file-actions {
                display: flex;
                align-items: center;
                gap: 0.5rem;
                margin-top: 0.75rem;
                padding-top: 0.75rem;
                border-top: 1px solid #e2e8f0;
            }
            
            /* Header info in spectrum viewer */
            .spectrum-info {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
                gap: 0.75rem;
                margin-bottom: 1rem;
                padding: 0.75rem;
                background: #0f172a;
                border-radius: 6px;
            }
            
            .spectrum-info-item {
                text-align: center;
            }
            
            .spectrum-info-label {
                color: #64748b;
                font-size: 0.7rem;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                margin-bottom: 0.25rem;
            }
            
            .spectrum-info-value {
                color: #e2e8f0;
                font-family: 'DM Mono', monospace;
                font-size: 0.85rem;
            }
        </style>

        <section id="results" class="results-section"></section>
        
        <!-- Spectrum Viewer Section -->
        <section id="spectrum-viewer" class="spectrum-viewer">
            <div class="spectrum-header">
                <div class="spectrum-title" id="spectrum-title">Spectrum</div>
                <button class="spectrum-close-btn" onclick="closeSpectrumViewer()">Close</button>
            </div>
            <div class="spectrum-info" id="spectrum-info"></div>
            <div class="spectrum-controls">
                <div class="control-group">
                    <label>Min λ (Å):</label>
                    <input type="number" id="min-wl" value="4000" step="100">
                </div>
                <div class="control-group">
                    <label>Max λ (Å):</label>
                    <input type="number" id="max-wl" value="5500" step="100">
                </div>
                <button class="spectrum-btn" onclick="applyWavelengthRange()">Apply</button>
                <button class="spectrum-btn" onclick="resetWavelengthRange()">Reset</button>
                <div class="control-group">
                    <label>bkspace:</label>
                    <input type="number" id="bkspace" value="100" step="10" min="10" max="500" style="width: 60px;">
                </div>
                <button class="spectrum-btn" id="flatten-btn" onclick="toggleFlatten()">Flatten</button>
                <button class="spectrum-btn" onclick="recalcSNR()" title="Recalculate SNR for current wavelength range">Calc SNR</button>
                <button class="spectrum-btn" id="bary-btn" onclick="toggleBarycentric()" title="Apply barycentric correction">Bary Corr</button>
                <span class="control-divider"></span>
                <span class="line-btn-group">
                    <button class="spectrum-btn line-btn" id="halpha-btn" onclick="toggleLine('halpha')">Hα</button>
                    <button class="spectrum-btn line-btn" id="lithium-btn" onclick="toggleLine('lithium')">Li I</button>
                </span>
            </div>
            <div class="spectrum-controls rv-controls">
                <div class="control-group">
                    <label>Template:</label>
                    <select id="template-select" class="template-select">
                        <option value="3500_spec.FITS">3500 K (M-type)</option>
                        <option value="5750_spec.FITS">5750 K (Solar)</option>
                        <option value="7250_spec.FITS">7250 K (F-type)</option>
                    </select>
                </div>
                <button class="spectrum-btn rv-btn" onclick="computeCCF()" title="Compute cross-correlation and radial velocity">
                    Compute RV
                </button>
                <div class="rv-result" id="rv-result"></div>
            </div>
            <div id="spectrum-plot"></div>
        </section>

        <div class="info-box">
            <strong>Data Access:</strong> Files are stored in the shared Dropbox folder and the shared Google Drive folder
            <code>SALT_data/2023-2-SCI-018/</code>. 
            For web plotting, FITS files should be in the <code>saltdata/</code> folder.
            
            <div class="help-toggle" onclick="toggleHelp()">
                ⓘ Need help finding the files? Click here
            </div>
            
            <div class="help-content" id="help-content">
                <p><strong>Option 1: Shared Dropbox folder (similar instructions for the shared Google Drive folder)</strong></p>
                <p>If you have access to the shared Dropbox, make sure it's synced locally:</p>
                <ol>
                    <li>Open the <strong>Dropbox app</strong> on your Mac (not just the website)</li>
                    <li>In the Dropbox menu bar icon, click <strong>Preferences</strong> (gear icon)</li>
                    <li>Go to the <strong>Sync</strong> tab</li>
                    <li>Click <strong>Select folders to sync</strong></li>
                    <li>Make sure <code>Data/SALT_data/2023-2-SCI-018</code> is checked</li>
                    <li>Click <strong>Update</strong> and wait for sync to complete</li>
                </ol>
                <p style="margin-top: 0.75rem;">
                    Once synced, files will appear in <code>~/Dropbox/Data/SALT_data/2023-2-SCI-018/</code> on your Mac.
                </p>
                
                <p style="margin-top: 1rem;"><strong>Option 2: Local copies</strong></p>
                <p>If you downloaded the data to your own folder, the paths shown here are relative. 
                   Just use the appropriate folder and product path (e.g., <code>231205/product/</code>) 
                   and navigate to that location within your local data directory.
                </p>
                <p style="margin-top: 0.5rem;">
                    For example, if your data lives in <code>/Users/jsheffler/Desktop/Salt_analysis/</code>, 
                    then <code>231205/product/</code> means <code>/Users/jsheffler/Desktop/Salt_analysis/231205/product/</code>.
                </p>
                
                <p style="margin-top: 1rem;">
                    Questions? Contact <a href="mailto:mmsoares@wisc.edu">mmsoares@wisc.edu</a>
                </p>
            </div>
        </div>

        <div class="stats-bar">
            <div class="stat">
                <div class="stat-value" id="total-nights">0</div>
                <div class="stat-label">Nights</div>
            </div>
            <div class="stat">
                <div class="stat-value" id="total-targets">0</div>
                <div class="stat-label">Targets</div>
            </div>
            <div class="stat">
                <div class="stat-value" id="total-obs">0</div>
                <div class="stat-label">Observations</div>
            </div>
            <div class="stat">
                <div class="stat-value" id="total-hq">0</div>
                <div class="stat-label">High Quality</div>
            </div>
        </div>
    </div>

    <script>
        const DROPBOX_FOLDER = '2023-2-SCI-018';
        const SALTDATA_FOLDER = 'saltdata';  // Folder containing FITS files for web viewing
        const MAX_RECENT_SEARCHES = 4;
        const TEAM_INSPECTION_CSV_URL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vTbg5XWBsfv8V74hLfu7e2cllY_FESOslL67pBSTQv51ZHL2ypGZC1iQyvi7QBCB_c-NWJ4HSrJRXja/pub?gid=1011669788&single=true&output=csv';
        
        let catalogData = null;
        let currentGaiaId = null;
        let teamInspectionData = {};
        const stellarDataCache = {};
        
        // ============================================
        // Spectrum Viewer State
        // ============================================
        let currentSpectrum = null;
        let isFlattened = false;
        
        // Helper functions for large arrays (avoid spread operator stack overflow)
        function arrayMin(arr) {
            let min = Infinity;
            for (let i = 0; i < arr.length; i++) {
                if (arr[i] < min && !isNaN(arr[i])) min = arr[i];
            }
            return min;
        }
        
        function arrayMax(arr) {
            let max = -Infinity;
            for (let i = 0; i < arr.length; i++) {
                if (arr[i] > max && !isNaN(arr[i])) max = arr[i];
            }
            return max;
        }
        
        // Spectral line markers
        const SPECTRAL_LINES = {
            halpha: { wavelength: 6562.8, label: 'Hα', color: '#ec4899' },
            lithium: { wavelength: 6707.8, label: 'Li I 6708', color: '#f59e0b' }
        };
        let showLines = { halpha: false, lithium: false };
        
        // Barycentric correction state
        let applyBaryCorr = false;
        
        // SALT Observatory coordinates
        const SALT_LAT = 32.37582222;   // degrees
        const SALT_LONG = 20.81080833;  // degrees East
        const SALT_ALT = 1798;          // meters
        const C_KMS = 299792.458;       // speed of light in km/s
        
        // ============================================
        // Barycentric Correction Calculator
        // Simplified implementation based on Earth's orbital motion
        // ============================================
        
        function degToRad(deg) {
            return deg * Math.PI / 180;
        }
        
        function radToDeg(rad) {
            return rad * 180 / Math.PI;
        }
        
        // Calculate Julian Date from Date object
        function dateToJD(date) {
            const year = date.getUTCFullYear();
            const month = date.getUTCMonth() + 1;
            const day = date.getUTCDate();
            const hour = date.getUTCHours();
            const minute = date.getUTCMinutes();
            const second = date.getUTCSeconds();
            
            let y = year;
            let m = month;
            if (m <= 2) {
                y -= 1;
                m += 12;
            }
            
            const A = Math.floor(y / 100);
            const B = 2 - A + Math.floor(A / 4);
            
            const jd = Math.floor(365.25 * (y + 4716)) + 
                       Math.floor(30.6001 * (m + 1)) + 
                       day + B - 1524.5 +
                       (hour + minute / 60 + second / 3600) / 24;
            
            return jd;
        }
        
        // Parse DATE-OBS string to JD
        function parseDateObsToJD(dateObs, jdHeader = null) {
            // If JD is directly in header, use it
            if (jdHeader && !isNaN(jdHeader)) {
                return jdHeader;
            }
            
            // Try to parse DATE-OBS (format: YYYY-MM-DDTHH:MM:SS)
            if (dateObs) {
                const date = new Date(dateObs);
                if (!isNaN(date.getTime())) {
                    return dateToJD(date);
                }
            }
            
            return null;
        }
        
        // Calculate barycentric velocity correction
        // This is a simplified calculation accounting for Earth's orbital motion
        function calculateBarycentricVelocity(jd, raDeg, decDeg) {
            if (!jd || raDeg === null || decDeg === null) {
                return 0;
            }
            
            // Convert to radians
            const ra = degToRad(raDeg);
            const dec = degToRad(decDeg);
            
            // Calculate mean longitude of the Sun
            // Days since J2000.0
            const d = jd - 2451545.0;
            
            // Mean anomaly of the Sun (degrees)
            const g = 357.529 + 0.98560028 * d;
            const gRad = degToRad(g % 360);
            
            // Mean longitude of the Sun (degrees)
            const L = 280.459 + 0.98564736 * d;
            const LRad = degToRad(L % 360);
            
            // Ecliptic longitude of the Sun
            const lambdaSun = L + 1.915 * Math.sin(gRad) + 0.020 * Math.sin(2 * gRad);
            const lambdaSunRad = degToRad(lambdaSun % 360);
            
            // Obliquity of the ecliptic
            const epsilon = degToRad(23.439 - 0.0000004 * d);
            
            // Sun's position in equatorial coordinates
            const raSun = Math.atan2(Math.cos(epsilon) * Math.sin(lambdaSunRad), Math.cos(lambdaSunRad));
            const decSun = Math.asin(Math.sin(epsilon) * Math.sin(lambdaSunRad));
            
            // Earth's orbital velocity (approximately 29.78 km/s)
            const vOrb = 29.78;
            
            // Earth's orbital velocity is perpendicular to the Sun direction
            // We need the component along the line of sight to the target
            
            // Direction to the Sun (from Earth)
            const sunX = Math.cos(decSun) * Math.cos(raSun);
            const sunY = Math.cos(decSun) * Math.sin(raSun);
            const sunZ = Math.sin(decSun);
            
            // Direction to the target
            const targetX = Math.cos(dec) * Math.cos(ra);
            const targetY = Math.cos(dec) * Math.sin(ra);
            const targetZ = Math.sin(dec);
            
            // Earth's velocity direction is perpendicular to Sun direction, in the ecliptic plane
            // Velocity is roughly 90 degrees ahead of Earth's position (behind the Sun)
            const vDirRA = raSun + Math.PI / 2;
            const vDirX = Math.cos(vDirRA);
            const vDirY = Math.sin(vDirRA);
            const vDirZ = 0; // Simplified: assume motion in ecliptic plane
            
            // Project Earth's velocity onto the line of sight to the target
            const vBary = vOrb * (vDirX * targetX + vDirY * targetY + vDirZ * targetZ);
            
            // Add approximate correction for Earth's rotation (smaller effect)
            const lst = (L / 15 + SALT_LONG / 15) % 24; // Local sidereal time (hours, approximate)
            const lstRad = degToRad(lst * 15);
            const latRad = degToRad(SALT_LAT);
            
            // Rotational velocity at SALT latitude
            const vRot = 0.4651 * Math.cos(latRad); // km/s at Earth's surface
            
            // Hour angle
            const ha = lstRad - ra;
            
            // Rotational component along line of sight
            const vRotProj = vRot * Math.cos(dec) * Math.sin(ha);
            
            return vBary + vRotProj;
        }
        
        // Apply barycentric correction to wavelength array
        function applyBarycentricCorrection(wavelength, vBary) {
            if (!vBary || vBary === 0) return wavelength;
            
            // λ_corrected = λ_observed * (1 + v_bary / c)
            const factor = 1 + (vBary / C_KMS);
            return wavelength.map(w => w * factor);
        }
        
        // Get target RA/Dec from catalog or header
        function getTargetCoords(gaiaId, header) {
            // First try to get from catalog
            if (catalogData && gaiaId) {
                const target = catalogData.targets.find(t => t.gaia_dr3_id === gaiaId);
                if (target && target.ra_deg !== undefined && target.dec_deg !== undefined) {
                    return { ra: target.ra_deg, dec: target.dec_deg };
                }
            }
            
            // Try header
            if (header) {
                const ra = header.RA || header.OBJRA;
                const dec = header.DEC || header.OBJDEC;
                if (ra !== undefined && dec !== undefined) {
                    return { ra: ra, dec: dec };
                }
            }
            
            return null;
        }
        
        function toggleBarycentric() {
            applyBaryCorr = !applyBaryCorr;
            document.getElementById('bary-btn').classList.toggle('active', applyBaryCorr);
            
            // Re-render the current spectrum
            if (currentSpectrum) {
                if (currentSpectrum.isMultiArm) {
                    plotBothArms(currentSpectrum.blue, currentSpectrum.red);
                } else {
                    applyWavelengthRange();
                }
            }
        }
        
        // Get barycentric-corrected wavelength
        function getCorrectedWavelength(wavelength, header, gaiaId) {
            if (!applyBaryCorr) return wavelength;
            
            const jd = parseDateObsToJD(header['DATE-OBS'], header['JD']);
            const coords = getTargetCoords(gaiaId, header);
            
            if (!jd || !coords) {
                console.warn('Cannot apply barycentric correction: missing JD or coordinates');
                return wavelength;
            }
            
            const vBary = calculateBarycentricVelocity(jd, coords.ra, coords.dec);
            console.log(`Barycentric velocity: ${vBary.toFixed(3)} km/s`);
            
            return applyBarycentricCorrection(wavelength, vBary);
        }
        
        // ============================================
        // SNR Calculation (DER_SNR method)
        // Based on Stoehr et al. 2008
        // ============================================
        
        function calculateSNR(flux, wavelength = null, minWl = null, maxWl = null) {
            let fluxArray = flux;
            
            // If wavelength range specified, filter to that range
            if (wavelength && minWl !== null && maxWl !== null) {
                const indices = [];
                for (let i = 0; i < wavelength.length; i++) {
                    if (wavelength[i] >= minWl && wavelength[i] <= maxWl) {
                        indices.push(i);
                    }
                }
                fluxArray = indices.map(i => flux[i]);
            }
            
            // Filter out NaN and Inf values
            fluxArray = fluxArray.filter(v => !isNaN(v) && isFinite(v) && v > 0);
            
            if (fluxArray.length < 5) return null;
            
            // DER_SNR method: noise from second derivative
            // noise = 1.482602 / sqrt(6) * median(|2*f[i] - f[i-2] - f[i+2]|)
            const derivs = [];
            for (let i = 2; i < fluxArray.length - 2; i++) {
                const d = Math.abs(2 * fluxArray[i] - fluxArray[i - 2] - fluxArray[i + 2]);
                derivs.push(d);
            }
            
            derivs.sort((a, b) => a - b);
            const medianDeriv = derivs[Math.floor(derivs.length / 2)];
            const noise = 1.482602 / Math.sqrt(6) * medianDeriv;
            
            // Signal: median flux
            const sortedFlux = [...fluxArray].sort((a, b) => a - b);
            const signal = sortedFlux[Math.floor(sortedFlux.length / 2)];
            
            if (noise <= 0) return null;
            
            return {
                snr: signal / noise,
                signal: signal,
                noise: noise,
                nPixels: fluxArray.length
            };
        }
        
        function formatSNR(snrResult) {
            if (!snrResult) return 'N/A';
            return snrResult.snr.toFixed(0);
        }
        
        // ============================================
        // Cross-Correlation and RV Measurement
        // ============================================
        
        // Cache for loaded templates
        const templateCache = {};
        
        // Parse FITS binary table extension (in extension 1)
        function parseFITSBinaryTable(buffer) {
            const decoder = new TextDecoder('ascii');
            let offset = 0;
            
            // Parse primary HDU header to skip it
            let foundEnd = false;
            const primaryHeader = {};
            
            while (!foundEnd && offset < buffer.byteLength) {
                const blockBytes = new Uint8Array(buffer, offset, Math.min(2880, buffer.byteLength - offset));
                const blockText = decoder.decode(blockBytes);
                
                for (let i = 0; i < 36; i++) {
                    const card = blockText.substring(i * 80, (i + 1) * 80);
                    const keyword = card.substring(0, 8).trim();
                    
                    if (keyword === 'END') {
                        foundEnd = true;
                        break;
                    }
                    
                    if (keyword && card.charAt(8) === '=') {
                        let valueStr = card.substring(10, 80).split('/')[0].trim();
                        if (valueStr !== '' && !valueStr.startsWith("'")) {
                            primaryHeader[keyword] = parseFloat(valueStr);
                        }
                    }
                }
                offset += 2880;
            }
            
            console.log('Primary header parsed, offset after header:', offset);
            console.log('Primary NAXIS:', primaryHeader.NAXIS);
            
            // Skip primary data if NAXIS > 0
            if (primaryHeader.NAXIS && primaryHeader.NAXIS > 0) {
                let dataSize = Math.abs(primaryHeader.BITPIX || 8) / 8;
                for (let i = 1; i <= primaryHeader.NAXIS; i++) {
                    dataSize *= (primaryHeader[`NAXIS${i}`] || 0);
                }
                if (dataSize > 0) {
                    const blocks = Math.ceil(dataSize / 2880);
                    offset += blocks * 2880;
                    console.log('Skipped primary data blocks:', blocks);
                }
            }
            
            console.log('Starting extension header at offset:', offset);
            
            // Now parse extension header
            foundEnd = false;
            const extHeader = {};
            
            while (!foundEnd && offset < buffer.byteLength) {
                const blockBytes = new Uint8Array(buffer, offset, Math.min(2880, buffer.byteLength - offset));
                const blockText = decoder.decode(blockBytes);
                
                for (let i = 0; i < 36; i++) {
                    const card = blockText.substring(i * 80, (i + 1) * 80);
                    const keyword = card.substring(0, 8).trim();
                    
                    if (keyword === 'END') {
                        foundEnd = true;
                        break;
                    }
                    
                    if (keyword && card.charAt(8) === '=') {
                        let valueStr = card.substring(10, 80).split('/')[0].trim();
                        
                        if (valueStr.startsWith("'")) {
                            extHeader[keyword] = valueStr.replace(/^'|'$/g, '').trim();
                        } else if (valueStr === 'T') {
                            extHeader[keyword] = true;
                        } else if (valueStr === 'F') {
                            extHeader[keyword] = false;
                        } else if (valueStr !== '') {
                            extHeader[keyword] = parseFloat(valueStr.replace('D', 'E'));
                        }
                    }
                }
                offset += 2880;
            }
            
            const extDataOffset = offset;
            
            console.log('Extension header:', extHeader);
            console.log('XTENSION:', extHeader.XTENSION);
            console.log('TFIELDS:', extHeader.TFIELDS);
            console.log('NAXIS1 (row bytes):', extHeader.NAXIS1);
            console.log('NAXIS2 (n rows):', extHeader.NAXIS2);
            console.log('Extension data starts at offset:', extDataOffset);
            
            return { extHeader, extDataOffset };
        }
        
        // Read binary table columns
        function readBinaryTableColumns(buffer, extHeader, extDataOffset) {
            const nRows = extHeader.NAXIS2 || 0;
            const rowBytes = extHeader.NAXIS1 || 0;
            const nFields = extHeader.TFIELDS || 0;
            const view = new DataView(buffer);
            
            console.log(`Reading ${nRows} rows, ${rowBytes} bytes/row, ${nFields} fields`);
            
            // Parse column info
            const columns = [];
            let byteOffset = 0;
            
            for (let i = 1; i <= nFields; i++) {
                const ttype = extHeader[`TTYPE${i}`] || `COL${i}`;
                const tform = extHeader[`TFORM${i}`] || 'E';
                
                // Parse TFORM - e.g., 'E' (float), 'D' (double), '1E', '1D'
                const match = tform.match(/(\d*)([EDJIK])/i);
                let count = 1;
                let dtype = 'E';
                let bytesPerElement = 4;
                
                if (match) {
                    count = match[1] ? parseInt(match[1]) : 1;
                    dtype = match[2].toUpperCase();
                }
                
                if (dtype === 'D') bytesPerElement = 8;      // 64-bit double
                else if (dtype === 'E') bytesPerElement = 4; // 32-bit float
                else if (dtype === 'J') bytesPerElement = 4; // 32-bit int
                else if (dtype === 'I') bytesPerElement = 2; // 16-bit int
                else if (dtype === 'K') bytesPerElement = 8; // 64-bit int
                
                columns.push({
                    name: ttype.toLowerCase(),
                    dtype: dtype,
                    count: count,
                    bytesPerElement: bytesPerElement,
                    offset: byteOffset
                });
                
                byteOffset += count * bytesPerElement;
                
                console.log(`Column ${i}: ${ttype}, format=${tform}, dtype=${dtype}, count=${count}, offset=${columns[columns.length-1].offset}`);
            }
            
            // Read data - for templates, read directly into trimmed range
            // SALT wavelength range is ~3500-9000 Å
            const data = {};
            columns.forEach(col => {
                data[col.name] = [];
            });
            
            // Find wavelength column index
            const wlColIdx = columns.findIndex(c => c.name === 'wavelength' || c.name === 'wave' || c.name === 'wl');
            const wlCol = wlColIdx >= 0 ? columns[wlColIdx] : null;
            
            // Trim to useful wavelength range (cap at 7000 Å to avoid tellurics in CCF)
            const minWl = 3400;
            const maxWl = 7100;
            let skippedLow = 0, skippedHigh = 0, kept = 0;
            
            for (let row = 0; row < nRows; row++) {
                const rowStart = extDataOffset + row * rowBytes;
                
                // First read wavelength to check if in range
                let wl = null;
                if (wlCol) {
                    const wlPos = rowStart + wlCol.offset;
                    if (wlCol.dtype === 'D') {
                        wl = view.getFloat64(wlPos, false);
                    } else if (wlCol.dtype === 'E') {
                        wl = view.getFloat32(wlPos, false);
                    }
                    
                    // Skip if outside SALT range
                    if (wl < minWl) { skippedLow++; continue; }
                    if (wl > maxWl) { skippedHigh++; continue; }
                }
                
                // Read all columns for this row
                for (const col of columns) {
                    const colStart = rowStart + col.offset;
                    
                    for (let j = 0; j < col.count; j++) {
                        const pos = colStart + j * col.bytesPerElement;
                        let value;
                        
                        if (col.dtype === 'D') {
                            value = view.getFloat64(pos, false);
                        } else if (col.dtype === 'E') {
                            value = view.getFloat32(pos, false);
                        } else if (col.dtype === 'J') {
                            value = view.getInt32(pos, false);
                        } else if (col.dtype === 'I') {
                            value = view.getInt16(pos, false);
                        } else if (col.dtype === 'K') {
                            value = Number(view.getBigInt64(pos, false));
                        }
                        
                        data[col.name].push(value);
                    }
                }
                kept++;
            }
            
            console.log(`Template rows: ${skippedLow} below range, ${skippedHigh} above range, ${kept} kept`);
            
            return data;
        }
        
        // Load a template spectrum from binary table FITS
        async function loadTemplate(templateFile) {
            if (templateCache[templateFile]) {
                return templateCache[templateFile];
            }
            
            try {
                const url = `${SALTDATA_FOLDER}/${templateFile}`;
                console.log('Loading template from:', url);
                
                const buffer = await fetchFITS(url);
                
                // Parse binary table extension
                const { extHeader, extDataOffset } = parseFITSBinaryTable(buffer);
                
                // Read columns (already trimmed to SALT wavelength range)
                const tableData = readBinaryTableColumns(buffer, extHeader, extDataOffset);
                
                console.log('Table columns found:', Object.keys(tableData));
                console.log('First 5 wavelength values:', tableData.wavelength?.slice(0, 5) || tableData.wave?.slice(0, 5) || 'N/A');
                console.log('First 5 flux values:', tableData.flux?.slice(0, 5) || 'N/A');
                
                // Get wavelength and flux
                const wavelength = tableData.wavelength || tableData.wave || tableData.wl || [];
                const flux = tableData.flux || tableData.spec || tableData.intensity || [];
                
                if (wavelength.length === 0 || flux.length === 0) {
                    throw new Error(`Could not find wavelength/flux columns or no data in SALT range. Available: ${Object.keys(tableData).join(', ')}`);
                }
                
                console.log('Template wavelength range:', arrayMin(wavelength).toFixed(1), '-', arrayMax(wavelength).toFixed(1), 'Å');
                console.log('Template n points:', wavelength.length);
                
                const data = { wavelength, flux, header: extHeader };
                templateCache[templateFile] = data;
                return data;
                
            } catch (error) {
                console.error('Error loading template:', error);
                throw error;
            }
        }
        
        // Interpolate spectrum onto a regular log-wavelength grid
        function interpolateToLogGrid(wavelength, flux, logWlMin, logWlMax, nPoints) {
            const logWlGrid = [];
            const fluxGrid = [];
            const step = (logWlMax - logWlMin) / (nPoints - 1);
            
            for (let i = 0; i < nPoints; i++) {
                logWlGrid.push(logWlMin + i * step);
            }
            
            // Convert input wavelengths to log
            const logWl = wavelength.map(w => Math.log(w));
            
            // Linear interpolation onto the grid
            for (let i = 0; i < logWlGrid.length; i++) {
                const targetLogWl = logWlGrid[i];
                
                // Find bracketing points
                let j = 0;
                while (j < logWl.length - 1 && logWl[j + 1] < targetLogWl) {
                    j++;
                }
                
                if (j >= logWl.length - 1 || logWl[j] > targetLogWl) {
                    fluxGrid.push(NaN);
                } else {
                    // Linear interpolation
                    const t = (targetLogWl - logWl[j]) / (logWl[j + 1] - logWl[j]);
                    fluxGrid.push(flux[j] + t * (flux[j + 1] - flux[j]));
                }
            }
            
            return { logWlGrid, fluxGrid };
        }
        
        // Normalize spectrum (subtract mean, divide by std)
        function normalizeSpectrum(flux) {
            const validFlux = flux.filter(f => !isNaN(f) && isFinite(f));
            if (validFlux.length === 0) return flux;
            
            const mean = validFlux.reduce((a, b) => a + b, 0) / validFlux.length;
            const std = Math.sqrt(validFlux.reduce((a, b) => a + (b - mean) ** 2, 0) / validFlux.length);
            
            if (std === 0) return flux.map(() => 0);
            return flux.map(f => isNaN(f) ? 0 : (f - mean) / std);
        }
        
        // Compute cross-correlation function
        function computeCrossCorrelationFunction(flux1, flux2, maxLag) {
            const n = flux1.length;
            const ccf = [];
            const lags = [];
            
            for (let lag = -maxLag; lag <= maxLag; lag++) {
                let sum = 0;
                let count = 0;
                
                for (let i = 0; i < n; i++) {
                    const j = i + lag;
                    if (j >= 0 && j < n && !isNaN(flux1[i]) && !isNaN(flux2[j])) {
                        sum += flux1[i] * flux2[j];
                        count++;
                    }
                }
                
                lags.push(lag);
                ccf.push(count > 0 ? sum / count : 0);
            }
            
            return { lags, ccf };
        }
        
        // Find CCF peak with parabolic interpolation
        function findCCFPeak(lags, ccf) {
            // Find the index of maximum
            let maxIdx = 0;
            let maxVal = ccf[0];
            
            for (let i = 1; i < ccf.length; i++) {
                if (ccf[i] > maxVal) {
                    maxVal = ccf[i];
                    maxIdx = i;
                }
            }
            
            // Parabolic interpolation for sub-pixel precision
            if (maxIdx > 0 && maxIdx < ccf.length - 1) {
                const y0 = ccf[maxIdx - 1];
                const y1 = ccf[maxIdx];
                const y2 = ccf[maxIdx + 1];
                
                const denom = 2 * (2 * y1 - y0 - y2);
                if (Math.abs(denom) > 1e-10) {
                    const delta = (y0 - y2) / denom;
                    return {
                        lag: lags[maxIdx] + delta,
                        peak: y1 - (y0 - y2) * delta / 4,
                        peakIdx: maxIdx
                    };
                }
            }
            
            return { lag: lags[maxIdx], peak: maxVal, peakIdx: maxIdx };
        }
        
        // Gaussian function
        function gaussian(x, amp, mean, sigma, offset) {
            return amp * Math.exp(-Math.pow(x - mean, 2) / (2 * sigma * sigma)) + offset;
        }
        
        // Simple Gaussian fit using least squares (Levenberg-Marquardt style iteration)
        function fitGaussian(xData, yData, initialGuess) {
            let [amp, mean, sigma, offset] = initialGuess;
            const maxIter = 100;
            const tolerance = 1e-6;
            
            for (let iter = 0; iter < maxIter; iter++) {
                // Compute residuals and Jacobian
                let sumResidSq = 0;
                const gradients = [0, 0, 0, 0];
                
                for (let i = 0; i < xData.length; i++) {
                    const x = xData[i];
                    const y = yData[i];
                    const pred = gaussian(x, amp, mean, sigma, offset);
                    const resid = y - pred;
                    sumResidSq += resid * resid;
                    
                    // Partial derivatives
                    const expTerm = Math.exp(-Math.pow(x - mean, 2) / (2 * sigma * sigma));
                    const dAmp = expTerm;
                    const dMean = amp * expTerm * (x - mean) / (sigma * sigma);
                    const dSigma = amp * expTerm * Math.pow(x - mean, 2) / Math.pow(sigma, 3);
                    const dOffset = 1;
                    
                    gradients[0] += resid * dAmp;
                    gradients[1] += resid * dMean;
                    gradients[2] += resid * dSigma;
                    gradients[3] += resid * dOffset;
                }
                
                // Simple gradient descent step
                const lr = 0.01;
                const newAmp = amp + lr * gradients[0];
                const newMean = mean + lr * gradients[1];
                const newSigma = Math.max(0.1, sigma + lr * gradients[2]);
                const newOffset = offset + lr * gradients[3];
                
                // Check convergence
                const change = Math.abs(newMean - mean);
                
                amp = newAmp;
                mean = newMean;
                sigma = newSigma;
                offset = newOffset;
                
                if (change < tolerance) break;
            }
            
            return { amp, mean, sigma, offset };
        }
        
        // Refine CCF peak with Gaussian fit
        function refineCCFPeakWithGaussian(velocities, ccf, initialPeakVel, width = 50) {
            // Extract region around peak
            const halfWidth = width / 2;
            const indices = [];
            
            for (let i = 0; i < velocities.length; i++) {
                if (velocities[i] >= initialPeakVel - halfWidth && velocities[i] <= initialPeakVel + halfWidth) {
                    indices.push(i);
                }
            }
            
            if (indices.length < 5) {
                return { mean: initialPeakVel, sigma: 10, amp: 1, offset: 0, success: false };
            }
            
            const xData = indices.map(i => velocities[i]);
            const yData = indices.map(i => ccf[i]);
            
            // Normalize CCF for fitting
            const maxCCF = arrayMax(yData);
            const minCCF = arrayMin(yData);
            const yNorm = yData.map(y => (y - minCCF) / (maxCCF - minCCF));
            
            // Initial guess
            const initialGuess = [
                1.0,                    // amplitude
                initialPeakVel,         // mean
                10,                     // sigma (km/s)
                0                       // offset
            ];
            
            try {
                const fit = fitGaussian(xData, yNorm, initialGuess);
                return { ...fit, success: true };
            } catch (e) {
                console.warn('Gaussian fit failed:', e);
                return { mean: initialPeakVel, sigma: 10, amp: 1, offset: 0, success: false };
            }
        }
        
        // Main CCF computation function
        async function computeCCF() {
            if (!currentSpectrum) {
                document.getElementById('rv-result').innerHTML = '<span class="error">No spectrum loaded</span>';
                return;
            }
            
            const templateFile = document.getElementById('template-select').value;
            if (!templateFile) {
                document.getElementById('rv-result').innerHTML = '<span class="error">Select a template</span>';
                return;
            }
            
            const rvResult = document.getElementById('rv-result');
            rvResult.innerHTML = '<span class="computing">Computing CCF...</span>';
            
            try {
                // Load template
                const template = await loadTemplate(templateFile);
                
                // Get observed spectrum (use appropriate arm or single spectrum)
                let obsWl, obsFlux;
                if (currentSpectrum.isMultiArm) {
                    // For multi-arm, use the blue arm (typically has more lines)
                    obsWl = currentSpectrum.blue.wavelength;
                    obsFlux = currentSpectrum.blue.flux;
                } else {
                    obsWl = currentSpectrum.wavelength;
                    obsFlux = currentSpectrum.flux;
                }
                
                // Apply barycentric correction if enabled
                if (applyBaryCorr) {
                    const header = currentSpectrum.isMultiArm ? currentSpectrum.blue.header : currentSpectrum.header;
                    obsWl = getCorrectedWavelength(obsWl, header, currentSpectrum.gaiaId);
                }
                
                // Filter out invalid values
                const validObsWl = obsWl.filter(w => !isNaN(w) && isFinite(w) && w > 0);
                const validTmpWl = template.wavelength.filter(w => !isNaN(w) && isFinite(w) && w > 0);
                
                if (validObsWl.length === 0 || validTmpWl.length === 0) {
                    console.error('Invalid wavelength arrays - obs:', obsWl.slice(0, 10), 'template:', template.wavelength.slice(0, 10));
                    rvResult.innerHTML = '<span class="error">Invalid wavelength data</span>';
                    return;
                }
                
                // Find overlapping wavelength range
                const obsMin = arrayMin(validObsWl);
                const obsMax = arrayMax(validObsWl);
                const tmpMin = arrayMin(validTmpWl);
                const tmpMax = arrayMax(validTmpWl);
                
                console.log('Observed wavelength range:', obsMin.toFixed(1), '-', obsMax.toFixed(1), 'Å');
                console.log('Template wavelength range:', tmpMin.toFixed(1), '-', tmpMax.toFixed(1), 'Å');
                
                const wlMin = Math.max(obsMin, tmpMin);
                let wlMax = Math.min(obsMax, tmpMax);
                
                // Cap at 7000 Å to avoid telluric contamination
                const telluricCutoff = 7000;
                if (wlMax > telluricCutoff) {
                    console.log(`Capping CCF range at ${telluricCutoff}Å to avoid tellurics`);
                    wlMax = telluricCutoff;
                }
                
                console.log('CCF range:', wlMin.toFixed(1), '-', wlMax.toFixed(1), 'Å');
                
                if (wlMin >= wlMax) {
                    rvResult.innerHTML = `<span class="error">No overlap: obs ${obsMin.toFixed(0)}-${obsMax.toFixed(0)}Å, template ${tmpMin.toFixed(0)}-${tmpMax.toFixed(0)}Å</span>`;
                    return;
                }
                
                // Use current view range if smaller (but still cap at telluric cutoff)
                const viewMin = parseFloat(document.getElementById('min-wl').value);
                const viewMax = Math.min(parseFloat(document.getElementById('max-wl').value), telluricCutoff);
                const rangeMin = Math.max(wlMin, viewMin);
                const rangeMax = Math.min(wlMax, viewMax);
                
                // Convert to log wavelength
                const logWlMin = Math.log(rangeMin);
                const logWlMax = Math.log(rangeMax);
                
                // Number of points and velocity step
                // Each pixel in log-wavelength corresponds to a fixed velocity
                const nPoints = 4096;
                const dLogWl = (logWlMax - logWlMin) / nPoints;
                const dv = C_KMS * dLogWl; // km/s per pixel
                
                // Interpolate both spectra onto the same log-wavelength grid
                const obsInterp = interpolateToLogGrid(obsWl, obsFlux, logWlMin, logWlMax, nPoints);
                const tmpInterp = interpolateToLogGrid(template.wavelength, template.flux, logWlMin, logWlMax, nPoints);
                
                // Normalize
                const obsNorm = normalizeSpectrum(obsInterp.fluxGrid);
                const tmpNorm = normalizeSpectrum(tmpInterp.fluxGrid);
                
                // Compute CCF with max velocity range of ±500 km/s
                const maxVel = 500; // km/s
                const maxLag = Math.ceil(maxVel / dv);
                
                const { lags, ccf } = computeCrossCorrelationFunction(obsNorm, tmpNorm, maxLag);
                
                // Convert lags to velocities
                const velocities = lags.map(l => l * dv);
                
                // Find initial peak
                const initialPeak = findCCFPeak(lags, ccf);
                const initialRV = initialPeak.lag * dv;
                
                // Refine with Gaussian fit (like the Python code)
                const gaussFit = refineCCFPeakWithGaussian(velocities, ccf, initialRV, 100);
                
                // Use Gaussian mean as final RV if fit succeeded
                const rv = gaussFit.success ? gaussFit.mean : initialRV;
                
                // Convert to wavelength offset at reference wavelength (5500 Å)
                const refWl = 5500;
                const dWl = refWl * rv / C_KMS;
                
                // Store CCF for optional display
                currentSpectrum.lastCCF = {
                    velocities: velocities,
                    ccf: ccf,
                    peakVel: rv,
                    peakCCF: initialPeak.peak,
                    dWl: dWl,
                    template: templateFile,
                    gaussFit: gaussFit
                };
                
                // Display result
                const sign = rv >= 0 ? '+' : '';
                const fitNote = gaussFit.success ? ` (σ=${gaussFit.sigma.toFixed(1)})` : ' (no fit)';
                rvResult.innerHTML = `
                    <span class="rv-label">RV:</span>
                    <span class="rv-value">${sign}${rv.toFixed(2)} km/s${fitNote}</span>
                    <span class="rv-label">Δλ:</span>
                    <span class="rv-value">${sign}${dWl.toFixed(3)} Å</span>
                    <span class="rv-label">CCF peak:</span>
                    <span class="rv-value">${initialPeak.peak.toFixed(3)}</span>
                    <button class="show-ccf-btn" onclick="showCCFPlot()">Show CCF</button>
                `;
                
            } catch (error) {
                console.error('CCF computation error:', error);
                rvResult.innerHTML = `<span class="error">Error: ${error.message}</span>`;
            }
        }
        
        // Show CCF plot in a modal or overlay
        function showCCFPlot() {
            if (!currentSpectrum || !currentSpectrum.lastCCF) return;
            
            const ccfData = currentSpectrum.lastCCF;
            
            // Create modal overlay
            let modal = document.getElementById('ccf-modal');
            if (!modal) {
                modal = document.createElement('div');
                modal.id = 'ccf-modal';
                modal.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0,0,0,0.8);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    z-index: 1000;
                `;
                modal.onclick = (e) => {
                    if (e.target === modal) modal.style.display = 'none';
                };
                document.body.appendChild(modal);
            }
            
            modal.innerHTML = `
                <div style="background: #1e293b; border-radius: 12px; padding: 1.5rem; width: 90%; max-width: 800px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                        <h3 style="color: #e2e8f0; margin: 0; font-family: 'DM Sans', sans-serif;">
                            Cross-Correlation Function
                        </h3>
                        <button onclick="document.getElementById('ccf-modal').style.display='none'" 
                            style="background: transparent; border: 1px solid #475569; color: #94a3b8; padding: 0.25rem 0.75rem; border-radius: 4px; cursor: pointer;">
                            Close
                        </button>
                    </div>
                    <div id="ccf-plot" style="width: 100%; height: 350px;"></div>
                    <div style="color: #94a3b8; font-size: 0.8rem; margin-top: 0.5rem; font-family: 'DM Sans', sans-serif;">
                        Template: ${ccfData.template} | Peak RV: ${ccfData.peakVel.toFixed(2)} km/s | Δλ: ${ccfData.dWl.toFixed(3)} Å
                    </div>
                </div>
            `;
            modal.style.display = 'flex';
            
            // Plot CCF
            const trace = {
                x: ccfData.velocities,
                y: ccfData.ccf,
                type: 'scatter',
                mode: 'lines',
                line: { color: '#a78bfa', width: 1.5 },
                hovertemplate: 'v = %{x:.1f} km/s<br>CCF = %{y:.4f}<extra></extra>'
            };
            
            // Add vertical line at peak
            const peakLine = {
                x: [ccfData.peakVel, ccfData.peakVel],
                y: [arrayMin(ccfData.ccf), ccfData.peakCCF],
                type: 'scatter',
                mode: 'lines',
                line: { color: '#f87171', width: 1.5, dash: 'dash' },
                showlegend: false,
                hoverinfo: 'skip'
            };
            
            const layout = {
                xaxis: { 
                    title: { text: 'Velocity (km/s)', font: { color: '#94a3b8', size: 12 } },
                    color: '#94a3b8',
                    gridcolor: '#334155',
                    zerolinecolor: '#475569',
                    tickfont: { color: '#94a3b8' }
                },
                yaxis: { 
                    title: { text: 'CCF', font: { color: '#94a3b8', size: 12 } },
                    color: '#94a3b8',
                    gridcolor: '#334155',
                    zerolinecolor: '#334155',
                    tickfont: { color: '#94a3b8' }
                },
                paper_bgcolor: '#0f172a',
                plot_bgcolor: '#0f172a',
                font: { color: '#e2e8f0', family: 'DM Sans, sans-serif' },
                margin: { t: 20, r: 30, b: 50, l: 60 },
                showlegend: false
            };
            
            Plotly.newPlot('ccf-plot', [trace, peakLine], layout, { responsive: true });
        }
        
        function recalcSNR() {
            if (!currentSpectrum) return;
            
            const minWl = parseFloat(document.getElementById('min-wl').value);
            const maxWl = parseFloat(document.getElementById('max-wl').value);
            
            if (currentSpectrum.isMultiArm) {
                // Recalculate for both arms within the wavelength range
                const blueSNR = calculateSNR(
                    currentSpectrum.blue.flux, 
                    currentSpectrum.blue.wavelength, 
                    minWl, maxWl
                );
                const redSNR = calculateSNR(
                    currentSpectrum.red.flux, 
                    currentSpectrum.red.wavelength, 
                    minWl, maxWl
                );
                
                // Update the info display
                const infoDiv = document.getElementById('spectrum-info');
                infoDiv.innerHTML = `
                    <div class="spectrum-info-item">
                        <div class="spectrum-info-label">Date-Obs</div>
                        <div class="spectrum-info-value">${currentSpectrum.blue.header['DATE-OBS'] || currentSpectrum.obsDate}</div>
                    </div>
                    <div class="spectrum-info-item">
                        <div class="spectrum-info-label">Blue Arm</div>
                        <div class="spectrum-info-value" style="color: #38bdf8;">${Math.floor(currentSpectrum.blue.wavelength[0])}–${Math.ceil(currentSpectrum.blue.wavelength[currentSpectrum.blue.wavelength.length-1])} Å</div>
                    </div>
                    <div class="spectrum-info-item">
                        <div class="spectrum-info-label">Red Arm</div>
                        <div class="spectrum-info-value" style="color: #f87171;">${Math.floor(currentSpectrum.red.wavelength[0])}–${Math.ceil(currentSpectrum.red.wavelength[currentSpectrum.red.wavelength.length-1])} Å</div>
                    </div>
                    <div class="spectrum-info-item">
                        <div class="spectrum-info-label">SNR (Blue)</div>
                        <div class="spectrum-info-value" style="color: #38bdf8;">${formatSNR(blueSNR)}${blueSNR ? ` @ ${minWl}–${maxWl}` : ''}</div>
                    </div>
                    <div class="spectrum-info-item">
                        <div class="spectrum-info-label">SNR (Red)</div>
                        <div class="spectrum-info-value" style="color: #f87171;">${formatSNR(redSNR)}${redSNR ? ` @ ${minWl}–${maxWl}` : ''}</div>
                    </div>
                `;
            } else {
                // Single spectrum
                const snrResult = calculateSNR(
                    currentSpectrum.flux, 
                    currentSpectrum.wavelength, 
                    minWl, maxWl
                );
                
                const snrDisplay = document.getElementById('snr-value');
                if (snrDisplay) {
                    snrDisplay.textContent = snrResult ? 
                        `${formatSNR(snrResult)} @ ${minWl}–${maxWl} Å` : 
                        'N/A (no data in range)';
                }
            }
        }
        
        function toggleLine(lineId) {
            showLines[lineId] = !showLines[lineId];
            document.getElementById(`${lineId}-btn`).classList.toggle('active', showLines[lineId]);
            updateSpectralLines();
        }
        
        function updateSpectralLines() {
            const plotDiv = document.getElementById('spectrum-plot');
            if (!plotDiv || !plotDiv.data) return;
            
            const shapes = [];
            const annotations = [];
            
            const minWl = parseFloat(document.getElementById('min-wl').value);
            const maxWl = parseFloat(document.getElementById('max-wl').value);
            
            for (const [lineId, line] of Object.entries(SPECTRAL_LINES)) {
                if (showLines[lineId] && line.wavelength >= minWl && line.wavelength <= maxWl) {
                    shapes.push({
                        type: 'line',
                        x0: line.wavelength,
                        x1: line.wavelength,
                        y0: 0,
                        y1: 1,
                        yref: 'paper',
                        line: { color: line.color, width: 1.5, dash: 'dash' }
                    });
                    annotations.push({
                        x: line.wavelength,
                        y: 1,
                        yref: 'paper',
                        text: line.label,
                        showarrow: false,
                        font: { color: line.color, size: 11 },
                        yanchor: 'bottom',
                        yshift: 5
                    });
                }
            }
            
            Plotly.relayout(plotDiv, { shapes: shapes, annotations: annotations });
        }
        
        function getSpectralLineShapes() {
            const shapes = [];
            const annotations = [];
            
            const minWl = parseFloat(document.getElementById('min-wl').value);
            const maxWl = parseFloat(document.getElementById('max-wl').value);
            
            for (const [lineId, line] of Object.entries(SPECTRAL_LINES)) {
                if (showLines[lineId] && line.wavelength >= minWl && line.wavelength <= maxWl) {
                    shapes.push({
                        type: 'line',
                        x0: line.wavelength,
                        x1: line.wavelength,
                        y0: 0,
                        y1: 1,
                        yref: 'paper',
                        line: { color: line.color, width: 1.5, dash: 'dash' }
                    });
                    annotations.push({
                        x: line.wavelength,
                        y: 1,
                        yref: 'paper',
                        text: line.label,
                        showarrow: false,
                        font: { color: line.color, size: 11 },
                        yanchor: 'bottom',
                        yshift: 5
                    });
                }
            }
            
            return { shapes, annotations };
        }

        // ============================================
        // FITS Parsing Functions
        // ============================================
        
        async function fetchFITS(url) {
            const response = await fetch(url);
            if (!response.ok) {
                throw new Error(`Failed to fetch FITS file: ${response.status} ${response.statusText}`);
            }
            return await response.arrayBuffer();
        }
        
        function parseFITSHeader(buffer) {
            const header = {};
            let offset = 0;
            let foundEnd = false;
            
            while (!foundEnd && offset < buffer.byteLength) {
                const blockBytes = new Uint8Array(buffer, offset, Math.min(2880, buffer.byteLength - offset));
                const blockText = new TextDecoder('ascii').decode(blockBytes);
                
                for (let i = 0; i < 36; i++) {
                    const card = blockText.substring(i * 80, (i + 1) * 80);
                    const keyword = card.substring(0, 8).trim();
                    
                    if (keyword === 'END') {
                        foundEnd = true;
                        break;
                    }
                    
                    if (keyword && card.charAt(8) === '=') {
                        let valueStr = card.substring(10, 80).split('/')[0].trim();
                        
                        if (valueStr.startsWith("'")) {
                            header[keyword] = valueStr.replace(/^'|'$/g, '').trim();
                        } else if (valueStr === 'T') {
                            header[keyword] = true;
                        } else if (valueStr === 'F') {
                            header[keyword] = false;
                        } else if (valueStr !== '') {
                            header[keyword] = parseFloat(valueStr.replace('D', 'E'));
                        }
                    }
                }
                offset += 2880;
            }
            
            return { header, dataOffset: offset };
        }
        
        function readFluxData(buffer, dataOffset, header) {
            const naxis1 = header.NAXIS1 || 0;
            const bitpix = header.BITPIX || -32;
            const view = new DataView(buffer);
            const flux = [];
            
            if (bitpix === -32) {
                for (let i = 0; i < naxis1; i++) {
                    flux.push(view.getFloat32(dataOffset + i * 4, false));
                }
            } else if (bitpix === -64) {
                for (let i = 0; i < naxis1; i++) {
                    flux.push(view.getFloat64(dataOffset + i * 8, false));
                }
            } else if (bitpix === 16) {
                const bzero = header.BZERO || 0;
                const bscale = header.BSCALE || 1;
                for (let i = 0; i < naxis1; i++) {
                    flux.push(bzero + bscale * view.getInt16(dataOffset + i * 2, false));
                }
            }
            
            return flux;
        }
        
        function calculateWavelength(header, nPixels) {
            const crval1 = header.CRVAL1 || 0;
            const cdelt1 = header.CDELT1 || header.CD1_1 || 1;
            const crpix1 = header.CRPIX1 || 1;
            
            return Array.from({ length: nPixels }, (_, i) => 
                crval1 + cdelt1 * ((i + 1) - crpix1)
            );
        }
        
        async function loadFITSSpectrum(filename) {
            const url = `${SALTDATA_FOLDER}/${filename}`;
            console.log('Loading FITS from:', url);
            
            const buffer = await fetchFITS(url);
            const { header, dataOffset } = parseFITSHeader(buffer);
            const flux = readFluxData(buffer, dataOffset, header);
            const wavelength = calculateWavelength(header, flux.length);
            
            return { wavelength, flux, header };
        }
        
        // ============================================
        // Spectrum Processing
        // ============================================
        
        // ============================================
        // Continuum Normalization (Running Median)
        // ============================================
        
        function flattenSpectrum(wavelength, flux, bkspace = null) {
            // Fast running median continuum fitting
            if (!bkspace) {
                bkspace = parseFloat(document.getElementById('bkspace').value) || 100;
            }
            
            const n = wavelength.length;
            if (n < 10) return flux.slice();
            
            // Calculate window size in pixels based on bkspace (in Angstroms)
            const wlRange = arrayMax(wavelength) - arrayMin(wavelength);
            const pixelsPerAngstrom = n / wlRange;
            const windowSize = Math.max(10, Math.floor(bkspace * pixelsPerAngstrom));
            const halfWindow = Math.floor(windowSize / 2);
            
            console.log(`Flattening with bkspace=${bkspace}Å, window=${windowSize}px`);
            
            // Running median for continuum
            const continuum = new Array(n);
            
            for (let i = 0; i < n; i++) {
                const start = Math.max(0, i - halfWindow);
                const end = Math.min(n, i + halfWindow + 1);
                
                // Get window values, filter invalid
                const windowVals = [];
                for (let j = start; j < end; j++) {
                    if (!isNaN(flux[j]) && isFinite(flux[j]) && flux[j] > 0) {
                        windowVals.push(flux[j]);
                    }
                }
                
                if (windowVals.length > 0) {
                    // Use upper percentile (75th) to avoid absorption lines
                    windowVals.sort((a, b) => a - b);
                    const idx = Math.floor(windowVals.length * 0.75);
                    continuum[i] = windowVals[idx];
                } else {
                    continuum[i] = 1;
                }
            }
            
            // Normalize
            return flux.map((f, i) => continuum[i] > 0 ? f / continuum[i] : f);
        }
        
        function trimSpectrum(wavelength, flux, minWl, maxWl) {
            const indices = wavelength.map((w, i) => ({ w, i }))
                .filter(({ w }) => w >= minWl && w <= maxWl)
                .map(({ i }) => i);
            
            return {
                wavelength: indices.map(i => wavelength[i]),
                flux: indices.map(i => flux[i])
            };
        }
        
        // ============================================
        // Spectrum Plotting
        // ============================================
        
        function plotSpectrum(wavelength, flux, title) {
            const trace = {
                x: wavelength,
                y: flux,
                type: 'scatter',
                mode: 'lines',
                line: { color: '#38bdf8', width: 1.2 },
                hovertemplate: 'λ = %{x:.2f} Å<br>Flux = %{y:.4f}<extra></extra>'
            };
            
            const { shapes, annotations } = getSpectralLineShapes();
            
            const layout = {
                title: null,
                xaxis: { 
                    title: { text: 'Wavelength (Å)', font: { color: '#94a3b8', size: 12 } },
                    color: '#94a3b8',
                    gridcolor: '#334155',
                    zerolinecolor: '#334155',
                    tickfont: { color: '#94a3b8' }
                },
                yaxis: { 
                    title: { text: isFlattened ? 'Normalized Flux' : 'Flux', font: { color: '#94a3b8', size: 12 } },
                    color: '#94a3b8',
                    gridcolor: '#334155',
                    zerolinecolor: '#334155',
                    tickfont: { color: '#94a3b8' }
                },
                paper_bgcolor: '#0f172a',
                plot_bgcolor: '#0f172a',
                font: { color: '#e2e8f0', family: 'DM Sans, sans-serif' },
                hovermode: 'closest',
                margin: { t: 20, r: 30, b: 50, l: 60 },
                shapes: shapes,
                annotations: annotations
            };
            
            const config = {
                responsive: true,
                displayModeBar: true,
                modeBarButtonsToRemove: ['select2d', 'lasso2d'],
                toImageButtonOptions: {
                    format: 'png',
                    filename: title.replace(/\s+/g, '_'),
                    height: 600,
                    width: 1200,
                    scale: 2
                }
            };
            
            Plotly.newPlot('spectrum-plot', [trace], layout, config);
        }
        
        // ============================================
        // Spectrum Viewer UI
        // ============================================
        
        async function viewSpectrum(filename, gaiaId, obsDate) {
            const viewer = document.getElementById('spectrum-viewer');
            const plotDiv = document.getElementById('spectrum-plot');
            const titleDiv = document.getElementById('spectrum-title');
            const infoDiv = document.getElementById('spectrum-info');
            
            viewer.classList.add('visible');
            plotDiv.innerHTML = '<div class="spectrum-loading">Loading spectrum</div>';
            titleDiv.textContent = `Gaia DR3 ${gaiaId} — ${obsDate}`;
            infoDiv.innerHTML = '';
            
            isFlattened = false;
            document.getElementById('flatten-btn').classList.remove('active');
            
            // Reset line toggles
            showLines = { halpha: false, lithium: false };
            document.getElementById('halpha-btn').classList.remove('active');
            document.getElementById('lithium-btn').classList.remove('active');
            
            // Reset barycentric correction
            applyBaryCorr = false;
            document.getElementById('bary-btn').classList.remove('active');
            
            try {
                const { wavelength, flux, header } = await loadFITSSpectrum(filename);
                
                currentSpectrum = { wavelength, flux, header, filename, gaiaId, obsDate };
                
                const minWl = Math.floor(wavelength[0]);
                const maxWl = Math.ceil(wavelength[wavelength.length - 1]);
                document.getElementById('min-wl').value = minWl;
                document.getElementById('max-wl').value = maxWl;
                
                // Calculate SNR
                const snrResult = calculateSNR(flux);
                
                infoDiv.innerHTML = `
                    <div class="spectrum-info-item">
                        <div class="spectrum-info-label">Date-Obs</div>
                        <div class="spectrum-info-value">${header['DATE-OBS'] || obsDate}</div>
                    </div>
                    <div class="spectrum-info-item">
                        <div class="spectrum-info-label">Exp Time</div>
                        <div class="spectrum-info-value">${header.EXPTIME ? header.EXPTIME.toFixed(1) + 's' : 'N/A'}</div>
                    </div>
                    <div class="spectrum-info-item">
                        <div class="spectrum-info-label">λ Range</div>
                        <div class="spectrum-info-value">${minWl}–${maxWl} Å</div>
                    </div>
                    <div class="spectrum-info-item">
                        <div class="spectrum-info-label">Pixels</div>
                        <div class="spectrum-info-value">${wavelength.length}</div>
                    </div>
                    <div class="spectrum-info-item">
                        <div class="spectrum-info-label">SNR</div>
                        <div class="spectrum-info-value" id="snr-value">${formatSNR(snrResult)}</div>
                    </div>
                    <div class="spectrum-info-item">
                        <div class="spectrum-info-label">File</div>
                        <div class="spectrum-info-value" style="font-size: 0.7rem;">${filename}</div>
                    </div>
                `;
                
                const title = `Gaia DR3 ${gaiaId} — ${obsDate}`;
                plotSpectrum(wavelength, flux, title);
                
                viewer.scrollIntoView({ behavior: 'smooth', block: 'start' });
                
            } catch (error) {
                console.error('Error loading spectrum:', error);
                plotDiv.innerHTML = `
                    <div class="spectrum-error">
                        <strong>Error loading spectrum:</strong> ${error.message}<br><br>
                        Make sure the FITS file <code>${filename}</code> exists in the <code>${SALTDATA_FOLDER}/</code> folder.
                    </div>
                `;
            }
        }
        
        function closeSpectrumViewer() {
            document.getElementById('spectrum-viewer').classList.remove('visible');
            currentSpectrum = null;
            // Reset line toggles
            showLines = { halpha: false, lithium: false };
            document.getElementById('halpha-btn').classList.remove('active');
            document.getElementById('lithium-btn').classList.remove('active');
            // Reset barycentric correction
            applyBaryCorr = false;
            document.getElementById('bary-btn').classList.remove('active');
        }
        
        function applyWavelengthRange() {
            if (!currentSpectrum) return;
            
            // Handle multi-arm case
            if (currentSpectrum.isMultiArm) {
                plotBothArms(currentSpectrum.blue, currentSpectrum.red);
                return;
            }
            
            const minWl = parseFloat(document.getElementById('min-wl').value);
            const maxWl = parseFloat(document.getElementById('max-wl').value);
            
            let wavelength = currentSpectrum.wavelength;
            let flux = currentSpectrum.flux;
            
            // Apply barycentric correction if enabled
            wavelength = getCorrectedWavelength(wavelength, currentSpectrum.header, currentSpectrum.gaiaId);
            
            if (isFlattened) {
                flux = flattenSpectrum(wavelength, flux);
            }
            
            const trimmed = trimSpectrum(wavelength, flux, minWl, maxWl);
            const title = `Gaia DR3 ${currentSpectrum.gaiaId} — ${currentSpectrum.obsDate}`;
            plotSpectrum(trimmed.wavelength, trimmed.flux, title);
        }
        
        function resetWavelengthRange() {
            if (!currentSpectrum) return;
            
            // Handle multi-arm case
            if (currentSpectrum.isMultiArm) {
                let blueWl = getCorrectedWavelength(currentSpectrum.blue.wavelength, currentSpectrum.blue.header, currentSpectrum.gaiaId);
                let redWl = getCorrectedWavelength(currentSpectrum.red.wavelength, currentSpectrum.red.header, currentSpectrum.gaiaId);
                const allWavelengths = [...blueWl, ...redWl];
                document.getElementById('min-wl').value = Math.floor(arrayMin(allWavelengths));
                document.getElementById('max-wl').value = Math.ceil(arrayMax(allWavelengths));
                plotBothArms(currentSpectrum.blue, currentSpectrum.red);
                return;
            }
            
            let wavelength = currentSpectrum.wavelength;
            let flux = currentSpectrum.flux;
            
            // Apply barycentric correction if enabled
            wavelength = getCorrectedWavelength(wavelength, currentSpectrum.header, currentSpectrum.gaiaId);
            
            if (isFlattened) {
                flux = flattenSpectrum(wavelength, flux);
            }
            
            document.getElementById('min-wl').value = Math.floor(wavelength[0]);
            document.getElementById('max-wl').value = Math.ceil(wavelength[wavelength.length - 1]);
            
            const title = `Gaia DR3 ${currentSpectrum.gaiaId} — ${currentSpectrum.obsDate}`;
            plotSpectrum(wavelength, flux, title);
        }
        
        function toggleFlatten() {
            if (!currentSpectrum) return;
            
            isFlattened = !isFlattened;
            document.getElementById('flatten-btn').classList.toggle('active', isFlattened);
            
            // Handle multi-arm case
            if (currentSpectrum.isMultiArm) {
                plotBothArms(currentSpectrum.blue, currentSpectrum.red);
                return;
            }
            
            applyWavelengthRange();
        }

        // ============================================
        // Team Inspection Data
        // ============================================
        
        async function loadTeamInspection() {
            try {
                const response = await fetch(TEAM_INSPECTION_CSV_URL);
                if (!response.ok) {
                    console.warn('Could not load team inspection data');
                    return;
                }
                
                const csvText = await response.text();
                const lines = csvText.split('\n');
                
                for (let i = 1; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (!line) continue;
                    
                    const cols = parseCSVLine(line);
                    if (cols.length < 3) continue;
                    
                    let gaiaId = cols[0].trim();
                    if (gaiaId.startsWith('Gaia DR3 ')) {
                        gaiaId = gaiaId.substring(9);
                    }
                    
                    const dateObserved = cols[1].trim();
                    const usableValue = cols[2].trim().toLowerCase();
                    const repeatInFall = cols.length > 3 ? cols[3].trim().toLowerCase() === 'yes' : false;
                    
                    if (usableValue === '') continue;
                    
                    const usable = usableValue === 'yes';
                    const key = `${gaiaId}_${dateObserved}`;
                    teamInspectionData[key] = { usable, repeatInFall };
                }
                
                console.log(`Loaded team inspection data for ${Object.keys(teamInspectionData).length} observations`);
            } catch (error) {
                console.warn('Error loading team inspection data:', error);
            }
        }
        
        function parseCSVLine(line) {
            const result = [];
            let current = '';
            let inQuotes = false;
            
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                
                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    result.push(current);
                    current = '';
                } else {
                    current += char;
                }
            }
            result.push(current);
            
            return result;
        }
        
        function getTeamInspectionStatus(gaiaId, obsDate) {
            let dateKey = obsDate;
            if (obsDate.includes('-')) {
                const parts = obsDate.split('-');
                dateKey = parts[0].slice(2) + parts[1] + parts[2];
            }
            const key = `${gaiaId}_${dateKey}`;
            return teamInspectionData[key] || null;
        }

        function getSpectralType(teff) {
            if (!teff) return null;
            if (teff >= 30000) return 'O';
            if (teff >= 10000) return 'B';
            if (teff >= 7500) return 'A';
            if (teff >= 6000) return 'F';
            if (teff >= 5200) return 'G';
            if (teff >= 3700) return 'K';
            if (teff >= 2400) return 'M';
            return 'L';
        }

        function drawCMD(canvas, data) {
            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;
            
            ctx.fillStyle = '#fff';
            ctx.fillRect(0, 0, w, h);
            
            const xMin = -0.5, xMax = 3.5;
            const yMin = -2, yMax = 14;
            const margin = { top: 15, right: 15, bottom: 35, left: 45 };
            const plotW = w - margin.left - margin.right;
            const plotH = h - margin.top - margin.bottom;
            
            function toX(bprp) { return margin.left + (bprp - xMin) / (xMax - xMin) * plotW; }
            function toY(mg) { return margin.top + (mg - yMin) / (yMax - yMin) * plotH; }
            
            const bands = [
                { range: [-0.3, 0.33], color: 'rgba(147, 170, 255, 0.15)' },
                { range: [0.33, 0.98], color: 'rgba(255, 235, 200, 0.25)' },
                { range: [0.98, 1.85], color: 'rgba(255, 200, 124, 0.2)' },
                { range: [1.85, 3.5], color: 'rgba(255, 150, 80, 0.15)' }
            ];
            
            for (const band of bands) {
                ctx.fillStyle = band.color;
                const x1 = toX(Math.max(band.range[0], xMin));
                const x2 = toX(Math.min(band.range[1], xMax));
                ctx.fillRect(x1, margin.top, x2 - x1, plotH);
            }
            
            const msPoints = [
                [-0.3, -1], [0.0, 1], [0.3, 2.5], [0.6, 3.5], [0.8, 4.5],
                [1.0, 5.5], [1.3, 6.5], [1.6, 8], [2.0, 9.5], [2.5, 11], [3.2, 13]
            ];
            
            ctx.strokeStyle = 'rgba(0,0,0,0.3)';
            ctx.lineWidth = 1.5;
            ctx.setLineDash([4, 3]);
            ctx.beginPath();
            for (let i = 0; i < msPoints.length; i++) {
                const x = toX(msPoints[i][0]);
                const y = toY(msPoints[i][1]);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
            ctx.setLineDash([]);
            
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(margin.left, margin.top);
            ctx.lineTo(margin.left, h - margin.bottom);
            ctx.lineTo(w - margin.right, h - margin.bottom);
            ctx.stroke();
            
            ctx.fillStyle = '#333';
            ctx.font = '11px "DM Sans", sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('BP − RP', w / 2, h - 8);
            
            ctx.save();
            ctx.translate(12, h / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('M_G (mag)', 0, 0);
            ctx.restore();
            
            ctx.font = '9px "DM Sans", sans-serif';
            ctx.textAlign = 'center';
            for (let bp = 0; bp <= 3; bp++) {
                const x = toX(bp);
                ctx.beginPath();
                ctx.moveTo(x, h - margin.bottom);
                ctx.lineTo(x, h - margin.bottom + 4);
                ctx.stroke();
                ctx.fillText(bp.toString(), x, h - margin.bottom + 14);
            }
            
            ctx.textAlign = 'right';
            for (let mg = 0; mg <= 12; mg += 4) {
                const y = toY(mg);
                ctx.beginPath();
                ctx.moveTo(margin.left - 4, y);
                ctx.lineTo(margin.left, y);
                ctx.stroke();
                ctx.fillText(mg.toString(), margin.left - 8, y + 3);
            }
            
            const sunX = toX(0.82);
            const sunY = toY(4.83);
            ctx.beginPath();
            ctx.arc(sunX, sunY, 5, 0, Math.PI * 2);
            ctx.strokeStyle = '#f59e0b';
            ctx.lineWidth = 1.5;
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(sunX, sunY, 1.5, 0, Math.PI * 2);
            ctx.fillStyle = '#f59e0b';
            ctx.fill();
            
            if (data && data.bp_rp != null && data.abs_g != null) {
                const starX = toX(data.bp_rp);
                const starY = toY(data.abs_g);
                
                ctx.fillStyle = '#3b82f6';
                ctx.beginPath();
                const r = 7;
                for (let i = 0; i < 5; i++) {
                    const angle = (i * 4 * Math.PI / 5) - Math.PI / 2;
                    const x = starX + r * Math.cos(angle);
                    const y = starY + r * Math.sin(angle);
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.fill();
                ctx.strokeStyle = '#1e40af';
                ctx.lineWidth = 1;
                ctx.stroke();
            } else {
                ctx.fillStyle = '#888';
                ctx.font = '11px "DM Sans", sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('No Gaia data', w / 2, h / 2);
            }
        }

        // ============================================
        // Recent searches
        // ============================================
        
        function getRecentSearches() {
            try {
                const stored = localStorage.getItem('saltRecentSearches');
                return stored ? JSON.parse(stored) : [];
            } catch {
                return [];
            }
        }

        function saveRecentSearch(gaiaId) {
            try {
                let recent = getRecentSearches();
                recent = recent.filter(id => id !== gaiaId);
                recent.unshift(gaiaId);
                recent = recent.slice(0, MAX_RECENT_SEARCHES);
                localStorage.setItem('saltRecentSearches', JSON.stringify(recent));
                renderRecentSearches();
            } catch {}
        }

        function renderRecentSearches() {
            const recent = getRecentSearches();
            const dropdown = document.getElementById('search-dropdown');
            
            if (recent.length === 0) {
                dropdown.innerHTML = '';
                return;
            }
            
            dropdown.innerHTML = `
                <div class="dropdown-label">Recent searches</div>
                ${recent.map(id => 
                    `<div class="dropdown-item" onmousedown="selectTarget('${id}')">${id}</div>`
                ).join('')}
            `;
        }
        
        function showDropdown() {
            const dropdown = document.getElementById('search-dropdown');
            const recent = getRecentSearches();
            if (recent.length > 0) {
                dropdown.classList.add('visible');
            }
        }
        
        function hideDropdown() {
            const dropdown = document.getElementById('search-dropdown');
            dropdown.classList.remove('visible');
        }

        // ============================================
        // External links
        // ============================================
        
        function showExternalLinks(gaiaId) {
            const simbadContainer = document.getElementById('simbad-link');
            const simbadUrl = document.getElementById('simbad-url');
            simbadUrl.href = `https://simbad.u-strasbg.fr/simbad/sim-id?Ident=Gaia+DR3+${gaiaId}`;
            simbadContainer.classList.add('visible');
            
            const vizierContainer = document.getElementById('vizier-link');
            const vizierUrl = document.getElementById('vizier-url');
            vizierUrl.href = `https://vizier.cds.unistra.fr/viz-bin/VizieR-4?-source=&-out.all&-c=Gaia+DR3+${gaiaId}&-c.rs=2`;
            vizierContainer.classList.add('visible');
        }

        function hideExternalLinks() {
            document.getElementById('simbad-link').classList.remove('visible');
            document.getElementById('vizier-link').classList.remove('visible');
        }
    
        // ============================================
        // Stellar data fetching
        // ============================================
        async function fetchStellarData(gaiaId) {
          if (stellarDataCache[gaiaId] !== undefined) {
            return stellarDataCache[gaiaId];
          }
          
          try {
            const url = 'https://tapvizier.cds.unistra.fr/TAPVizieR/tap/sync';
            
            const query = `
              SELECT "Source", "Gmag", "BPmag", "RPmag", "Plx", "e_Plx", "Teff", "RV", "e_RV", "RUWE"
              FROM "I/355/gaiadr3"
              WHERE "Source" = '${gaiaId}'
            `;
            
            const params = new URLSearchParams({
              REQUEST: 'doQuery',
              LANG: 'ADQL',
              FORMAT: 'json',
              QUERY: query.replace(/\s+/g, ' ').trim()
            });
            
            const response = await fetch(url, {
              method: 'POST',
              headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
              body: params
            });
            
            if (!response.ok) throw new Error('VizieR query failed');
            
            const data = await response.json();
            
            if (data.data && data.data.length > 0) {
              const row = data.data[0];
              const result = {
                source_id: String(row[0]),
                g_mag: row[1],
                bp_mag: row[2],
                rp_mag: row[3],
                parallax: row[4],
                parallax_error: row[5],
                teff: row[6],
                rv: row[7],
                rv_error: row[8],
                ruwe: row[9],
                bp_rp: (row[2] && row[3]) ? row[2] - row[3] : null,
                distance: row[4] > 0 ? 1000 / row[4] : null,
                abs_g: (row[1] && row[4] > 0) ? row[1] - 5 * Math.log10(1000 / row[4]) + 5 : null
              };
              stellarDataCache[gaiaId] = result;
              return result;
            }
          } catch (error) {
            console.warn('Could not fetch stellar data from VizieR:', error);
          }
          
          stellarDataCache[gaiaId] = null;
          return null;
        }

        function toggleHelp() {
            document.getElementById('help-content').classList.toggle('visible');
        }

        // ============================================
        // Catalog loading
        // ============================================
        
        async function loadCatalog() {
            try {
                const [catalogResponse] = await Promise.all([
                    fetch('./index.json'),
                    loadTeamInspection()
                ]);
                
                if (!catalogResponse.ok) throw new Error('Catalog not found');
                catalogData = await catalogResponse.json();
                
                document.getElementById('total-targets').textContent = catalogData.targets.length;
                const totalObs = catalogData.targets.reduce((sum, t) => sum + t.observations.length, 0);
                document.getElementById('total-obs').textContent = totalObs;
                
                let hqCount = 0;
                catalogData.targets.forEach(t => {
                    t.observations.forEach(obs => {
                        const catalogStatus = obs.quality_status || 'Accepted';
                        const teamStatus = getTeamInspectionStatus(t.gaia_dr3_id, obs.date);
                        const passesTeamInspection = !teamStatus || teamStatus.usable;
                        
                        if (catalogStatus === 'Accepted' && passesTeamInspection) {
                            hqCount++;
                        }
                    });
                });
                document.getElementById('total-hq').textContent = hqCount;
                
                const nights = new Set();
                catalogData.targets.forEach(t => t.observations.forEach(o => nights.add(o.date)));
                document.getElementById('total-nights').textContent = nights.size;
            } catch (error) {
                console.error('Error loading catalog:', error);
                showStatus('Unable to load observation catalog.', true);
            }
        }

        // ============================================
        // Search
        // ============================================
        
        function searchTarget() {
            const gaiaId = document.getElementById('gaia-id').value.trim();
            if (!gaiaId) { 
                showStatus('Please enter a Gaia DR3 source ID.', true); 
                hideExternalLinks();
                return; 
            }
            if (!catalogData) { 
                showStatus('Catalog not loaded. Please refresh.', true); 
                return; 
            }

            const target = catalogData.targets.find(t => t.gaia_dr3_id === gaiaId);
            if (!target) { 
                showStatus(`No observations found for Gaia DR3 ${gaiaId}`, true); 
                hideExternalLinks();
                return; 
            }

            currentGaiaId = gaiaId;
            saveRecentSearch(gaiaId);
            showExternalLinks(gaiaId);
            closeSpectrumViewer();
            displayResults(target);
        }

        function getDQMPassCount(target) {
            let passCount = 0;
            
            for (const obs of target.observations) {
                const catalogStatus = obs.quality_status || 'Accepted';
                const teamStatus = getTeamInspectionStatus(target.gaia_dr3_id, obs.date);
                const passesTeamInspection = !teamStatus || teamStatus.usable;
                
                if (catalogStatus === 'Accepted' && passesTeamInspection) {
                    passCount++;
                }
            }
            
            return passCount;
        }

        async function loadStellarData(gaiaId) {
            const btn = document.getElementById('load-cmd-btn');
            const container = document.getElementById('stellar-section-container');
            
            if (btn) {
                btn.disabled = true;
                btn.textContent = 'Loading...';
            }
            
            const stellarData = await fetchStellarData(gaiaId);
            
            container.innerHTML = `
                <div class="stellar-section">
                    <div class="stellar-header">
                        <button class="collapse-cmd-btn" onclick="collapseStellarSection('${gaiaId}')">Hide</button>
                    </div>
                    <div class="cmd-container">
                        <canvas id="cmd-canvas" width="280" height="260"></canvas>
                    </div>
                    <div class="stellar-params" id="stellar-params">
                        <div class="param-row">
                            <span class="param-label">G mag</span>
                            <span class="param-value">${stellarData?.g_mag?.toFixed(2) || 'N/A'}</span>
                        </div>
                        <div class="param-row">
                            <span class="param-label">BP − RP</span>
                            <span class="param-value">${stellarData?.bp_rp?.toFixed(2) || 'N/A'}</span>
                        </div>
                        <div class="param-row">
                            <span class="param-label">Distance</span>
                            <span class="param-value">${stellarData?.distance ? stellarData.distance.toFixed(1) + ' pc' : 'N/A'}</span>
                        </div>
                        <div class="param-row">
                            <span class="param-label">Spectral Type</span>
                            <span class="param-value">${getSpectralType(stellarData?.teff) || 'N/A'}</span>
                        </div>
                        <div class="param-row">
                            <span class="param-label">Teff</span>
                            <span class="param-value">${stellarData?.teff ? Math.round(stellarData.teff) + ' K' : 'N/A'}</span>
                        </div>
                        <div class="param-row">
                            <span class="param-label">Radial Velocity</span>
                            <span class="param-value">${stellarData?.rv ? stellarData.rv.toFixed(1) + ' ± ' + (stellarData.rv_error?.toFixed(1) || '?') + ' km/s' : 'N/A'}</span>
                        </div>
                        <div class="param-row">
                            <span class="param-label">RUWE</span>
                            <span class="param-value">${stellarData?.ruwe?.toFixed(2) || 'N/A'}</span>
                        </div>
                    </div>
                </div>
            `;
            
            const canvas = document.getElementById('cmd-canvas');
            if (canvas) {
                drawCMD(canvas, stellarData);
            }
        }
        
        function collapseStellarSection(gaiaId) {
            const container = document.getElementById('stellar-section-container');
            container.innerHTML = `
                <div class="stellar-section-placeholder">
                    <button id="load-cmd-btn" class="load-cmd-btn" onclick="loadStellarData('${gaiaId}')">
                        Load CMD &amp; Stellar Parameters
                    </button>
                </div>
            `;
        }

        function findPlottableFile(allFiles) {
            const uwmFile = allFiles.find(f => f.includes('_uwm'));
            if (uwmFile) return uwmFile;
            
            const mergedFile = allFiles.find(f => f.includes('_1wm') || f.includes('_2wm'));
            if (mergedFile) return mergedFile;
            
            const fitsFile = allFiles.find(f => f.endsWith('.fits'));
            return fitsFile || null;
        }
        
        // Find matching blue (H) and red (R) arm files
        function findBothArmFiles(allFiles) {
            // Look for _uwm files first (merged, wavelength-calibrated)
            const blueUwm = allFiles.find(f => f.includes('H') && f.includes('_uwm'));
            const redUwm = allFiles.find(f => f.includes('R') && f.includes('_uwm'));
            
            if (blueUwm && redUwm) {
                return { blue: blueUwm, red: redUwm };
            }
            
            // Fall back to _1wm/_2wm merged files
            const blue1wm = allFiles.find(f => f.includes('H') && (f.includes('_1wm') || f.includes('_2wm')));
            const red1wm = allFiles.find(f => f.includes('R') && (f.includes('_1wm') || f.includes('_2wm')));
            
            if (blue1wm && red1wm) {
                return { blue: blue1wm, red: red1wm };
            }
            
            return null;
        }
        
        // Plot both arms together
        async function viewBothArms(blueFile, redFile, gaiaId, obsDate) {
            const viewer = document.getElementById('spectrum-viewer');
            const plotDiv = document.getElementById('spectrum-plot');
            const titleDiv = document.getElementById('spectrum-title');
            const infoDiv = document.getElementById('spectrum-info');
            
            viewer.classList.add('visible');
            plotDiv.innerHTML = '<div class="spectrum-loading">Loading both spectra</div>';
            titleDiv.textContent = `Gaia DR3 ${gaiaId} — ${obsDate} (Blue + Red)`;
            infoDiv.innerHTML = '';
            
            isFlattened = false;
            document.getElementById('flatten-btn').classList.remove('active');
            
            // Reset line toggles
            showLines = { halpha: false, lithium: false };
            document.getElementById('halpha-btn').classList.remove('active');
            document.getElementById('lithium-btn').classList.remove('active');
            
            // Reset barycentric correction
            applyBaryCorr = false;
            document.getElementById('bary-btn').classList.remove('active');
            
            try {
                // Load both spectra in parallel
                const [blueData, redData] = await Promise.all([
                    loadFITSSpectrum(blueFile),
                    loadFITSSpectrum(redFile)
                ]);
                
                // Store both for later use
                currentSpectrum = { 
                    blue: blueData,
                    red: redData,
                    gaiaId, 
                    obsDate,
                    isMultiArm: true
                };
                
                // Calculate combined wavelength range
                const allWavelengths = [...blueData.wavelength, ...redData.wavelength];
                const minWl = Math.floor(arrayMin(allWavelengths));
                const maxWl = Math.ceil(arrayMax(allWavelengths));
                
                document.getElementById('min-wl').value = minWl;
                document.getElementById('max-wl').value = maxWl;
                
                // Calculate SNR for both arms
                const blueSNR = calculateSNR(blueData.flux);
                const redSNR = calculateSNR(redData.flux);
                
                // Display header info for both
                infoDiv.innerHTML = `
                    <div class="spectrum-info-item">
                        <div class="spectrum-info-label">Date-Obs</div>
                        <div class="spectrum-info-value">${blueData.header['DATE-OBS'] || obsDate}</div>
                    </div>
                    <div class="spectrum-info-item">
                        <div class="spectrum-info-label">Blue Arm</div>
                        <div class="spectrum-info-value" style="color: #38bdf8;">${Math.floor(blueData.wavelength[0])}–${Math.ceil(blueData.wavelength[blueData.wavelength.length-1])} Å</div>
                    </div>
                    <div class="spectrum-info-item">
                        <div class="spectrum-info-label">Red Arm</div>
                        <div class="spectrum-info-value" style="color: #f87171;">${Math.floor(redData.wavelength[0])}–${Math.ceil(redData.wavelength[redData.wavelength.length-1])} Å</div>
                    </div>
                    <div class="spectrum-info-item">
                        <div class="spectrum-info-label">SNR (Blue)</div>
                        <div class="spectrum-info-value" style="color: #38bdf8;">${formatSNR(blueSNR)}</div>
                    </div>
                    <div class="spectrum-info-item">
                        <div class="spectrum-info-label">SNR (Red)</div>
                        <div class="spectrum-info-value" style="color: #f87171;">${formatSNR(redSNR)}</div>
                    </div>
                `;
                
                // Plot both
                plotBothArms(blueData, redData);
                
                viewer.scrollIntoView({ behavior: 'smooth', block: 'start' });
                
            } catch (error) {
                console.error('Error loading spectra:', error);
                plotDiv.innerHTML = `
                    <div class="spectrum-error">
                        <strong>Error loading spectra:</strong> ${error.message}<br><br>
                        Make sure both FITS files exist in the <code>${SALTDATA_FOLDER}/</code> folder:<br>
                        • Blue: <code>${blueFile}</code><br>
                        • Red: <code>${redFile}</code>
                    </div>
                `;
            }
        }
        
        function plotBothArms(blueData, redData) {
            let blueWl = blueData.wavelength;
            let blueFlux = blueData.flux;
            let redWl = redData.wavelength;
            let redFlux = redData.flux;
            
            // Apply barycentric correction if enabled
            if (currentSpectrum) {
                blueWl = getCorrectedWavelength(blueWl, blueData.header, currentSpectrum.gaiaId);
                redWl = getCorrectedWavelength(redWl, redData.header, currentSpectrum.gaiaId);
            }
            
            if (isFlattened) {
                blueFlux = flattenSpectrum(blueWl, blueFlux);
                redFlux = flattenSpectrum(redWl, redFlux);
            }
            
            // Apply wavelength range if set
            const minWl = parseFloat(document.getElementById('min-wl').value);
            const maxWl = parseFloat(document.getElementById('max-wl').value);
            
            const blueTrimmed = trimSpectrum(blueWl, blueFlux, minWl, maxWl);
            const redTrimmed = trimSpectrum(redWl, redFlux, minWl, maxWl);
            
            const traces = [
                {
                    x: blueTrimmed.wavelength,
                    y: blueTrimmed.flux,
                    type: 'scatter',
                    mode: 'lines',
                    name: 'Blue arm (H)',
                    line: { color: '#38bdf8', width: 1.2 },
                    hovertemplate: 'Blue<br>λ = %{x:.2f} Å<br>Flux = %{y:.4f}<extra></extra>'
                },
                {
                    x: redTrimmed.wavelength,
                    y: redTrimmed.flux,
                    type: 'scatter',
                    mode: 'lines',
                    name: 'Red arm (R)',
                    line: { color: '#f87171', width: 1.2 },
                    hovertemplate: 'Red<br>λ = %{x:.2f} Å<br>Flux = %{y:.4f}<extra></extra>'
                }
            ];
            
            const { shapes, annotations } = getSpectralLineShapes();
            
            const layout = {
                title: null,
                xaxis: { 
                    title: { text: 'Wavelength (Å)', font: { color: '#94a3b8', size: 12 } },
                    color: '#94a3b8',
                    gridcolor: '#334155',
                    zerolinecolor: '#334155',
                    tickfont: { color: '#94a3b8' }
                },
                yaxis: { 
                    title: { text: isFlattened ? 'Normalized Flux' : 'Flux', font: { color: '#94a3b8', size: 12 } },
                    color: '#94a3b8',
                    gridcolor: '#334155',
                    zerolinecolor: '#334155',
                    tickfont: { color: '#94a3b8' }
                },
                paper_bgcolor: '#0f172a',
                plot_bgcolor: '#0f172a',
                font: { color: '#e2e8f0', family: 'DM Sans, sans-serif' },
                hovermode: 'closest',
                margin: { t: 20, r: 30, b: 50, l: 60 },
                legend: {
                    x: 1,
                    y: 1,
                    xanchor: 'right',
                    bgcolor: 'rgba(15, 23, 42, 0.8)',
                    bordercolor: '#334155',
                    borderwidth: 1,
                    font: { color: '#e2e8f0' }
                },
                showlegend: true,
                shapes: shapes,
                annotations: annotations
            };
            
            const config = {
                responsive: true,
                displayModeBar: true,
                modeBarButtonsToRemove: ['select2d', 'lasso2d'],
                toImageButtonOptions: {
                    format: 'png',
                    filename: `spectrum_${currentSpectrum.gaiaId}_${currentSpectrum.obsDate}`,
                    height: 600,
                    width: 1200,
                    scale: 2
                }
            };
            
            Plotly.newPlot('spectrum-plot', traces, layout, config);
        }

        // ============================================
        // Display results
        // ============================================
        
        async function displayResults(target) {
            const resultsSection = document.getElementById('results');
            const dqmPassCount = getDQMPassCount(target);
            
            const sortedObs = [...target.observations].sort((a, b) => {
                const dateA = a.date.includes('-') ? a.date : `20${a.date.slice(0,2)}-${a.date.slice(2,4)}-${a.date.slice(4,6)}`;
                const dateB = b.date.includes('-') ? b.date : `20${b.date.slice(0,2)}-${b.date.slice(2,4)}-${b.date.slice(4,6)}`;
                return dateA.localeCompare(dateB);
            });
            
            const obsHtml = sortedObs.map((obs, idx) => {
                const allFiles = obs.all_files || [obs.filename];
                const mainFile = obs.filename;
                const dropboxPath = obs.dropbox_path || '';
                const fullPath = `${DROPBOX_FOLDER}/${dropboxPath}`;
                
                const plottableFile = findPlottableFile(allFiles);
                
                const catalogStatus = obs.quality_status || 'Accepted';
                const catalogReason = obs.quality_reason;
                const teamStatus = getTeamInspectionStatus(target.gaia_dr3_id, obs.date);
                
                let qualityHtml = '';
                
                if (catalogStatus === 'Rejected') {
                    qualityHtml = `<span class="quality-badge rejected">Rejected${catalogReason ? `: ${catalogReason}` : ''}</span>`;
                } else if (teamStatus && !teamStatus.usable) {
                    qualityHtml = `<span class="quality-badge team-rejected">Team Rejected</span>`;
                } else {
                    qualityHtml = `<span class="quality-badge accepted">Accepted</span>`;
                }
                
                const conditionsHtml = obs.conditions ? 
                    `<div class="obs-conditions">☁ ${obs.conditions}${obs.seeing ? ` · Seeing: ${obs.seeing}"` : ''}</div>` : 
                    (obs.seeing ? `<div class="obs-conditions">Seeing: ${obs.seeing}"</div>` : '');
                
                return `
                    <div class="obs-item">
                        <div class="obs-header" onclick="toggleFiles(${idx})">
                            <div class="obs-info">
                                <div class="obs-date">${obs.date} ${qualityHtml}</div>
                                <div class="obs-details">
                                    ${obs.instrument} · ${obs.mode || 'Standard'} · ${obs.exposure_time}s · ${allFiles.length} files
                                </div>
                                ${conditionsHtml}
                            </div>
                            <span class="expand-icon">▼</span>
                        </div>
                        <div class="obs-files" id="files-${idx}">
                            <div class="files-grid">
                                ${allFiles.map(f => {
                                    const isMain = f === mainFile;
                                    const badge = getFileBadge(f);
                                    return `<div class="file-item">${badge ? `<span class="file-badge ${isMain ? 'main' : ''}">${badge}</span>` : ''}<span>${f}</span></div>`;
                                }).join('')}
                            </div>
                            ${plottableFile ? `
                            <div class="file-actions">
                                <button class="plot-spectrum-btn" onclick="viewSpectrum('${plottableFile}', '${target.gaia_dr3_id}', '${obs.date}'); event.stopPropagation();">
                                    📈 Plot Spectrum
                                </button>
                                ${(() => {
                                    const bothArms = findBothArmFiles(allFiles);
                                    if (bothArms) {
                                        return `<button class="plot-spectrum-btn plot-both-btn" onclick="viewBothArms('${bothArms.blue}', '${bothArms.red}', '${target.gaia_dr3_id}', '${obs.date}'); event.stopPropagation();">
                                            📊 Plot Both Arms
                                        </button>`;
                                    }
                                    return '';
                                })()}
                                <span style="color: #64748b; font-size: 0.75rem;">Using: ${plottableFile}</span>
                            </div>
                            ` : ''}
                        </div>
                    </div>
                `;
            }).join('');

            resultsSection.innerHTML = `
                <div class="result-card">
                    <div class="result-header">
                        <div class="target-name">Gaia DR3 ${target.gaia_dr3_id}</div>
                        <div class="coords">
                            RA: ${target.ra_deg?.toFixed(6) || 'N/A'}° · Dec: ${target.dec_deg?.toFixed(6) || 'N/A'}°
                            ${target.common_name ? ` · ${target.common_name}` : ''}
                        </div>
                    </div>
                    <div class="result-body">
                        <div class="meta-grid">
                            <div class="meta-item">
                                <div class="meta-label">Observations</div>
                                <div class="meta-value">${target.observations.length}</div>
                            </div>
                            <div class="meta-item">
                                <div class="meta-label">DQM Pass</div>
                                <div class="meta-value">${dqmPassCount} / ${target.observations.length}</div>
                            </div>
                            <div class="meta-item">
                                <div class="meta-label">Program</div>
                                <div class="meta-value">${target.program || 'General'}</div>
                            </div>
                            <div class="meta-item">
                                <div class="meta-label">Notes</div>
                                <div class="meta-value">${target.notes || 'None'}</div>
                            </div>
                        </div>
                        <div class="observations-header">Observations</div>
                        ${obsHtml}
                        
                        <div id="stellar-section-container">
                            <div class="stellar-section-placeholder">
                                <button id="load-cmd-btn" class="load-cmd-btn" onclick="loadStellarData('${target.gaia_dr3_id}')">
                                    Load CMD &amp; Stellar Parameters
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            resultsSection.classList.add('visible');
        }

        function showAllTargets() {
            if (!catalogData) return;
            hideExternalLinks();
            closeSpectrumViewer();
            currentGaiaId = null;
            
            const resultsSection = document.getElementById('results');
            const sortedTargets = [...catalogData.targets].sort((a, b) => 
                b.observations.length - a.observations.length
            );
            
            resultsSection.innerHTML = `
                <div class="all-targets">
                    <h2>All Targets (${catalogData.targets.length})</h2>
                    <div class="target-list">
                        ${sortedTargets.map(t => `
                            <div class="target-item" onclick="selectTarget('${t.gaia_dr3_id}')">
                                <div class="gaia-id">${t.gaia_dr3_id}</div>
                                <div class="obs-count">${t.observations.length} obs</div>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
            resultsSection.classList.add('visible');
        }

        function selectTarget(gaiaId) {
            document.getElementById('gaia-id').value = gaiaId;
            searchTarget();
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        function toggleFiles(idx) {
            const filesDiv = document.getElementById(`files-${idx}`);
            const header = filesDiv.previousElementSibling;
            filesDiv.classList.toggle('expanded');
            header.classList.toggle('expanded');
        }

        function getFileBadge(filename) {
            if (filename.includes('_uwm')) return 'merged';
            if (filename.includes('_1wm') || filename.includes('_2wm')) return 'merged';
            if (filename.includes('_1we') || filename.includes('_2we')) return 'extracted';
            if (filename.includes('_1w.') || filename.includes('_2w.')) return 'wavelength';
            if (filename.includes('SNR')) return 'SNR';
            return null;
        }

        function showStatus(message, isError = false) {
            const resultsSection = document.getElementById('results');
            resultsSection.innerHTML = `<div class="status ${isError ? 'error' : ''}"><p>${message}</p></div>`;
            resultsSection.classList.add('visible');
        }

        // ============================================
        // Init
        // ============================================
        
        const gaiaInput = document.getElementById('gaia-id');
        
        gaiaInput.addEventListener('keypress', e => { 
            if (e.key === 'Enter') searchTarget(); 
        });
        
        gaiaInput.addEventListener('focus', () => {
            renderRecentSearches();
            showDropdown();
        });
        
        gaiaInput.addEventListener('blur', () => {
            setTimeout(hideDropdown, 150);
        });
        
        loadCatalog();
    </script>
</body>
</html>
