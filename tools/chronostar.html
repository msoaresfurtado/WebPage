<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Convergent Point RV + Identifier Resolver</title>
  <style>
    :root { color-scheme: light dark; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; margin: 20px; line-height: 1.35; }
    h1 { font-size: 20px; margin: 0 0 14px; }
    h2 { font-size: 16px; margin: 18px 0 10px; }
    .grid { display: grid; grid-template-columns: repeat(12, 1fr); gap: 10px; }
    .card { border: 1px solid rgba(127,127,127,0.35); border-radius: 10px; padding: 14px; background: rgba(127,127,127,0.06); }
    .row { display: grid; grid-template-columns: 170px 1fr; gap: 10px; align-items: center; margin: 8px 0; }
    label { font-size: 13px; opacity: 0.9; }
    input, textarea, select, button {
      width: 100%; box-sizing: border-box; padding: 8px 10px; border-radius: 8px;
      border: 1px solid rgba(127,127,127,0.35); background: transparent; font: inherit;
    }
    textarea { min-height: 120px; resize: vertical; }
    button { cursor: pointer; }
    .muted { opacity: 0.7; font-size: 12px; }
    .out { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; font-size: 13px; white-space: pre-wrap; }
    .col-6 { grid-column: span 6; }
    .col-12 { grid-column: span 12; }
    .pill { display: inline-block; padding: 2px 8px; border-radius: 999px; border: 1px solid rgba(127,127,127,0.35); font-size: 12px; opacity: 0.85; }
    .err { color: #c0392b; }
    .ok { color: #2ecc71; }
    @media (max-width: 900px) { .col-6 { grid-column: span 12; } .row { grid-template-columns: 1fr; } }
  </style>
</head>
<body>
  <h1>Convergent Point RV Predictor + Identifier Resolver</h1>

  <div class="grid">
    <div class="card col-6">
      <h2>Convergent point RV</h2>

      <div class="row">
        <label for="raDeg">Star RA (deg)</label>
        <input id="raDeg" type="number" step="any" value="120.0" />
      </div>
      <div class="row">
        <label for="decDeg">Star Dec (deg)</label>
        <input id="decDeg" type="number" step="any" value="10.0" />
      </div>

      <div class="row">
        <label for="parallaxMas">Parallax (mas)</label>
        <input id="parallaxMas" type="number" step="any" value="10.0" />
      </div>
      <div class="row">
        <label for="distancePc">Distance (pc) (optional)</label>
        <input id="distancePc" type="number" step="any" placeholder="Overrides parallax if set" />
      </div>

      <div class="row">
        <label for="pmRaMasYr">pmRA* (mas/yr) (optional)</label>
        <input id="pmRaMasYr" type="number" step="any" value="40.0" />
      </div>
      <div class="row">
        <label for="pmDecMasYr">pmDec (mas/yr) (optional)</label>
        <input id="pmDecMasYr" type="number" step="any" value="-15.0" />
      </div>

      <hr style="border:none;border-top:1px solid rgba(127,127,127,0.25);margin:14px 0;"/>

      <div class="row">
        <label for="cpRaDeg">CP RA (deg)</label>
        <input id="cpRaDeg" type="number" step="any" value="90.0" />
      </div>
      <div class="row">
        <label for="cpDecDeg">CP Dec (deg)</label>
        <input id="cpDecDeg" type="number" step="any" value="20.0" />
      </div>

      <div class="row">
        <label for="speedMode">Group speed mode</label>
        <select id="speedMode">
          <option value="known" selected>Known group speed (V)</option>
          <option value="fromMu">Infer V from muTowards</option>
        </select>
      </div>

      <div class="row" id="rowGroupSpeed">
        <label for="groupSpeedKmS">Group speed V (km/s)</label>
        <input id="groupSpeedKmS" type="number" step="any" value="20.0" />
      </div>

      <div class="row" id="rowMuTowards" style="display:none;">
        <label for="muTowardsMasYr">muTowards (mas/yr)</label>
        <input id="muTowardsMasYr" type="number" step="any" value="25.0" />
      </div>

      <div class="row">
        <label for="rvObservedKmS">Observed RV (km/s) (optional)</label>
        <input id="rvObservedKmS" type="number" step="any" placeholder="e.g. 15.2" value="15.2" />
      </div>

      <div class="row">
        <div></div>
        <button id="btnCompute">Compute</button>
      </div>

      <div class="muted">
        Predicted RV uses: <span class="pill">RV = V cos(λ)</span>. If inferring V from muTowards: <span class="pill">V = (4.74047 μ d)/sin(λ)</span>.
      </div>

      <div id="rvOutput" class="out" style="margin-top:10px;"></div>
    </div>

    <div class="card col-6">
      <h2>Identifier resolution</h2>

      <div class="row">
        <label for="idQuery">Query</label>
        <input id="idQuery" type="text" value="TOI-04364" />
      </div>

      <div class="row">
        <label for="candidates">Candidates (one per line)</label>
        <textarea id="candidates">TOI-4364
toi4364
TOI-4364 b
TIC 115595346
KELT-20
Kepler-1313
TOI-7032
TOI-5882</textarea>
      </div>

      <div class="row">
        <div></div>
        <button id="btnResolve">Resolve</button>
      </div>

      <div class="muted">
        Sorting prioritizes: exact(raw) → exact(normalized) → prefix → substring → Levenshtein similarity.
      </div>

      <div id="idOutput" class="out" style="margin-top:10px;"></div>
    </div>

    <div class="card col-12">
      <h2>Extras: compute muTowards from pmRA/pmDec</h2>
      <div class="muted">
        If you provided pmRA* and pmDec above, this computes the component toward the convergent point using the position angle.
      </div>
      <div class="row">
        <div></div>
        <button id="btnMuTowards">Compute muTowards from pm</button>
      </div>
      <div id="muOutput" class="out"></div>
    </div>
  </div>

  <script>
    // =========================
    // Math + astro helpers
    // =========================
    const K_AU_PER_YR_KM_S = 4.74047;

    function degToRad(deg) { return deg * Math.PI / 180.0; }
    function clamp(x, lo, hi) { return Math.max(lo, Math.min(hi, x)); }

    function angularSeparationRad(a, b) {
      const ra1 = degToRad(a.raDeg);
      const dec1 = degToRad(a.decDeg);
      const ra2 = degToRad(b.raDeg);
      const dec2 = degToRad(b.decDeg);

      const s1 = Math.sin(dec1), c1 = Math.cos(dec1);
      const s2 = Math.sin(dec2), c2 = Math.cos(dec2);
      const dRa = ra2 - ra1;

      const cosSep = clamp(s1 * s2 + c1 * c2 * Math.cos(dRa), -1, 1);
      return Math.acos(cosSep);
    }

    // Position angle (east of north) of point b as seen from a, in radians [0,2π)
    function positionAngleRad(a, b) {
      const ra1 = degToRad(a.raDeg);
      const dec1 = degToRad(a.decDeg);
      const ra2 = degToRad(b.raDeg);
      const dec2 = degToRad(b.decDeg);

      const dRa = ra2 - ra1;
      const y = Math.sin(dRa) * Math.cos(dec2);
      const x = Math.cos(dec1) * Math.sin(dec2) - Math.sin(dec1) * Math.cos(dec2) * Math.cos(dRa);

      let pa = Math.atan2(y, x);
      if (pa < 0) pa += 2 * Math.PI;
      return pa;
    }

    function getDistancePc(star) {
      if (Number.isFinite(star.distancePc) && star.distancePc > 0) return star.distancePc;
      if (Number.isFinite(star.parallaxMas) && star.parallaxMas > 0) return 1000.0 / star.parallaxMas;
      throw new Error("Distance is required: provide distancePc or a positive parallaxMas.");
    }

    function computePredictedRVConvergent(star, model) {
      const cp = { raDeg: model.raDeg, decDeg: model.decDeg };
      const lambda = angularSeparationRad(star, cp);
      const cosLambda = Math.cos(lambda);
      const sinLambda = Math.sin(lambda);

      let V;
      if (model.groupSpeedFromMuTowards && model.groupSpeedFromMuTowards.muTowardsMasYr != null) {
        if (Math.abs(sinLambda) < 1e-10) {
          throw new Error("Convergent inversion unstable: sin(lambda) ~ 0 near CP/anti-CP. Provide groupSpeedKmS instead.");
        }
        const dPc = getDistancePc(star);
        const muArcsecYr = model.groupSpeedFromMuTowards.muTowardsMasYr / 1000.0;
        const Vtan = K_AU_PER_YR_KM_S * muArcsecYr * dPc;
        V = Vtan / sinLambda;
      } else if (Number.isFinite(model.groupSpeedKmS)) {
        V = model.groupSpeedKmS;
      } else {
        throw new Error("Model must provide either groupSpeedKmS or groupSpeedFromMuTowards.muTowardsMasYr.");
      }

      return V * cosLambda;
    }

    function computeVelocityOffsetConvergent(rvObservedKmS, star, model) {
      const rvPred = computePredictedRVConvergent(star, model);
      return rvObservedKmS - rvPred;
    }

    function computeMuTowardsConvergentPointMasYr(star, cp) {
      if (!Number.isFinite(star.pmRaMasYr) || !Number.isFinite(star.pmDecMasYr)) {
        throw new Error("pmRaMasYr and pmDecMasYr are required to compute muTowards.");
      }
      const pa = positionAngleRad(star, cp); // east of north
      const pmEast = star.pmRaMasYr;
      const pmNorth = star.pmDecMasYr;
      return pmNorth * Math.cos(pa) + pmEast * Math.sin(pa);
    }

    // =========================
    // Identifier resolver
    // =========================
    function normalizeIdentifier(s) {
      const lower = (s ?? "").trim().toLowerCase();
      const stripped = lower.replace(/[\s._\-+/():,]/g, "");
      return stripped.replace(/([a-z])0+(\d)/g, "$1$2");
    }

    function levenshtein(a, b) {
      const n = a.length, m = b.length;
      if (n === 0) return m;
      if (m === 0) return n;

      const dp = new Array(m + 1);
      for (let j = 0; j <= m; j++) dp[j] = j;

      for (let i = 1; i <= n; i++) {
        let prevDiag = dp[0];
        dp[0] = i;
        for (let j = 1; j <= m; j++) {
          const temp = dp[j];
          const cost = (a[i - 1] === b[j - 1]) ? 0 : 1;
          dp[j] = Math.min(
            dp[j] + 1,
            dp[j - 1] + 1,
            prevDiag + cost
          );
          prevDiag = temp;
        }
      }
      return dp[m];
    }

    function similarityFromDistance(a, b, dist) {
      const denom = Math.max(1, Math.max(a.length, b.length));
      return 1.0 - dist / denom;
    }

    function startsWithScore(query, candidate) {
      if (candidate.startsWith(query) && query.length > 0) {
        return 0.90 + 0.10 * (query.length / Math.max(1, candidate.length));
      }
      return 0;
    }

    function containsScore(query, candidate) {
      const idx = candidate.indexOf(query);
      if (idx >= 0 && query.length > 0) {
        const posBonus = 1.0 - idx / Math.max(1, candidate.length);
        return 0.70 + 0.20 * posBonus;
      }
      return 0;
    }

    function resolveIdentifier(query, items) {
      const qRaw = query ?? "";
      const qNorm = normalizeIdentifier(qRaw);

      const scored = items.map((idRaw) => {
        const idNorm = normalizeIdentifier(idRaw);

        let score = 0;
        let reason = "levenshtein";

        if (idRaw === qRaw) {
          score = 1.0;
          reason = "exact(raw)";
        } else if (idNorm === qNorm && qNorm.length > 0) {
          score = 0.98;
          reason = "exact(normalized)";
        } else {
          const prefix = startsWithScore(qNorm, idNorm);
          if (prefix > 0) {
            score = prefix;
            reason = "prefix";
          } else {
            const contains = containsScore(qNorm, idNorm);
            if (contains > 0) {
              score = contains;
              reason = "substring";
            } else {
              const dist = levenshtein(qNorm, idNorm);
              score = 0.10 + 0.60 * similarityFromDistance(qNorm, idNorm, dist);
              reason = "levenshtein";
            }
          }
        }

        // tiny tiebreak: prefer shorter IDs if scores are basically equal
        score += 1e-6 * (1.0 / Math.max(1, idNorm.length));

        return { idRaw, score, reason, idNorm };
      });

      scored.sort((a, b) => b.score - a.score);
      return scored;
    }

    // =========================
    // UI glue
    // =========================
    function readNum(id) {
      const v = document.getElementById(id).value;
      if (v === "" || v == null) return undefined;
      const x = Number(v);
      return Number.isFinite(x) ? x : undefined;
    }

    function setSpeedModeUI() {
      const mode = document.getElementById("speedMode").value;
      document.getElementById("rowGroupSpeed").style.display = (mode === "known") ? "" : "none";
      document.getElementById("rowMuTowards").style.display = (mode === "fromMu") ? "" : "none";
    }

    function formatKmS(x) {
      return `${x.toFixed(4)} km/s`;
    }

    function computeRV() {
      const out = document.getElementById("rvOutput");
      out.textContent = "";

      try {
        const star = {
          raDeg: readNum("raDeg"),
          decDeg: readNum("decDeg"),
          parallaxMas: readNum("parallaxMas"),
          distancePc: readNum("distancePc"),
          pmRaMasYr: readNum("pmRaMasYr"),
          pmDecMasYr: readNum("pmDecMasYr"),
        };

        if (!Number.isFinite(star.raDeg) || !Number.isFinite(star.decDeg)) {
          throw new Error("Star RA/Dec are required.");
        }

        const model = {
          raDeg: readNum("cpRaDeg"),
          decDeg: readNum("cpDecDeg"),
          groupSpeedKmS: undefined,
          groupSpeedFromMuTowards: undefined,
        };

        if (!Number.isFinite(model.raDeg) || !Number.isFinite(model.decDeg)) {
          throw new Error("Convergent point RA/Dec are required.");
        }

        const mode = document.getElementById("speedMode").value;
        if (mode === "known") {
          const V = readNum("groupSpeedKmS");
          if (!Number.isFinite(V)) throw new Error("Provide a finite group speed V (km/s).");
          model.groupSpeedKmS = V;
        } else {
          const mu = readNum("muTowardsMasYr");
          if (!Number.isFinite(mu)) throw new Error("Provide a finite muTowards (mas/yr).");
          model.groupSpeedFromMuTowards = { muTowardsMasYr: mu };
        }

        const rvPred = computePredictedRVConvergent(star, model);
        const cp = { raDeg: model.raDeg, decDeg: model.decDeg };
        const lambda = angularSeparationRad(star, cp);
        const lambdaDeg = lambda * 180 / Math.PI;

        const lines = [];
        lines.push(`λ (star–CP separation): ${lambdaDeg.toFixed(6)} deg`);
        lines.push(`Predicted RV: ${formatKmS(rvPred)}`);

        const rvObs = readNum("rvObservedKmS");
        if (Number.isFinite(rvObs)) {
          const offset = computeVelocityOffsetConvergent(rvObs, star, model);
          lines.push(`Observed RV:  ${formatKmS(rvObs)}`);
          lines.push(`Offset (obs - pred): ${formatKmS(offset)}`);
        } else {
          lines.push(`Observed RV:  (not provided)`);
          lines.push(`Offset:       (not computed)`);
        }

        out.classList.remove("err");
        out.textContent = lines.join("\n");
      } catch (e) {
        out.classList.add("err");
        out.textContent = `Error: ${e?.message ?? String(e)}`;
      }
    }

    function computeMuTowardsUI() {
      const out = document.getElementById("muOutput");
      out.textContent = "";

      try {
        const star = {
          raDeg: readNum("raDeg"),
          decDeg: readNum("decDeg"),
          pmRaMasYr: readNum("pmRaMasYr"),
          pmDecMasYr: readNum("pmDecMasYr"),
        };
        const cp = {
          raDeg: readNum("cpRaDeg"),
          decDeg: readNum("cpDecDeg"),
        };

        if (!Number.isFinite(star.raDeg) || !Number.isFinite(star.decDeg)) throw new Error("Star RA/Dec are required.");
        if (!Number.isFinite(cp.raDeg) || !Number.isFinite(cp.decDeg)) throw new Error("CP RA/Dec are required.");

        const mu = computeMuTowardsConvergentPointMasYr(star, cp);
        const pa = positionAngleRad(star, cp) * 180 / Math.PI;
        out.classList.remove("err");
        out.textContent =
          `Position angle to CP (east of north): ${pa.toFixed(6)} deg\n` +
          `muTowards: ${mu.toFixed(6)} mas/yr\n\n` +
          `Tip: You can paste this muTowards into “Infer V from muTowards” mode.`;
      } catch (e) {
        out.classList.add("err");
        out.textContent = `Error: ${e?.message ?? String(e)}`;
      }
    }

    function resolveIDs() {
      const out = document.getElementById("idOutput");
      out.textContent = "";

      const q = document.getElementById("idQuery").value ?? "";
      const lines = (document.getElementById("candidates").value ?? "")
        .split("\n")
        .map(s => s.trim())
        .filter(s => s.length > 0);

      if (!lines.length) {
        out.classList.add("err");
        out.textContent = "Error: Add at least one candidate ID.";
        return;
      }

      const scored = resolveIdentifier(q, lines);

      const best = scored[0];
      const buf = [];
      buf.push(`Query: "${q}"   (normalized: "${normalizeIdentifier(q)}")`);
      buf.push(`Best:  "${best.idRaw}"   score=${best.score.toFixed(6)}   reason=${best.reason}`);
      buf.push("");
      buf.push("Ordered matches:");
      for (const s of scored) {
        buf.push(`- ${s.score.toFixed(6)}  ${s.reason.padEnd(15)}  "${s.idRaw}"  (norm="${s.idNorm}")`);
      }

      out.classList.remove("err");
      out.textContent = buf.join("\n");
    }

    // wire up
    document.getElementById("btnCompute").addEventListener("click", computeRV);
    document.getElementById("btnResolve").addEventListener("click", resolveIDs);
    document.getElementById("btnMuTowards").addEventListener("click", computeMuTowardsUI);
    document.getElementById("speedMode").addEventListener("change", () => {
      setSpeedModeUI();
      computeRV();
    });

    // initial
    setSpeedModeUI();
    computeRV();
    resolveIDs();
  </script>
</body>
</html>
